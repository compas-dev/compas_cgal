{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Documentation of COMPAS CGAL","text":"<p>COMPAS CGAL provides easy-to-use Python bindings for selected algorithms of CGAL, The Computational Geometry Algorithms Library.</p>"},{"location":"acknowledgements/","title":"Acknowledgements","text":""},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#unreleased","title":"Unreleased","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>Added  <code>compas_cgal.skeletonization.mesh_skeleton_with_mapping</code></li> <li><code>HeatGeodesicSolver</code> class with precomputation for repeated queries</li> <li> <p><code>heat_geodesic_distances</code> function for single-shot usage</p> <ul> <li>uses CGAL Heat_method_3 with intrinsic Delaunay triangulation</li> <li>~30% faster than <code>libigl</code> heat in <code>compas_slicer</code> workflow</li> </ul> </li> <li> <p>Added <code>simplify_polyline</code> and <code>simplify_polylines</code> functions for polyline simplification using Douglas-Peucker algorithm</p> </li> <li>Added <code>closest_points_on_polyline</code> function for batch closest point queries on polylines</li> </ul>"},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li> <p>Added optional surface meshing parameters (<code>sm_angle</code>, <code>sm_radius</code>, <code>sm_distance</code>) to <code>compas_cgal.reconstruction.poisson_surface_reconstruction</code> for controlling mesh quality and density.</p> </li> <li> <p><code>subdivision</code>: pass-by-value \u2192 Eigen::Ref (3 functions) <li><code>straight_skeleton_2</code>: const&amp; \u2192 Eigen::Ref (8 functions) <li><code>triangulation</code>: added const to all Eigen::Ref params (3 functions)</li> <li><code>meshing</code>: removed extra &amp; and added const (7 functions)</li>"},{"location":"changelog/#removed","title":"Removed","text":""},{"location":"changelog/#091-2025-06-26","title":"[0.9.1] 2025-06-26","text":""},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li>Added <code>compas_cgal.meshing.trimesh_dual</code>.</li> <li>Added <code>compas_cgal.meshing.project_mesh_on_mesh</code>.</li> <li>Added <code>compas_cgal.meshing.project_points_on_mesh</code>.</li> <li>Added <code>compas_cgal.meshing.pull_mesh_on_mesh</code>.</li> </ul>"},{"location":"changelog/#changed_1","title":"Changed","text":"<ul> <li>Changed <code>compas_cgal.meshing.mesh_remesh</code> to <code>compas_cgal.meshing.trimesh_remesh</code>.</li> </ul>"},{"location":"changelog/#removed_1","title":"Removed","text":""},{"location":"changelog/#090-2025-04-18","title":"[0.9.0] 2025-04-18","text":""},{"location":"changelog/#added_2","title":"Added","text":""},{"location":"changelog/#changed_2","title":"Changed","text":""},{"location":"changelog/#removed_2","title":"Removed","text":""},{"location":"changelog/#080-2025-03-24","title":"[0.8.0] 2025-03-24","text":""},{"location":"changelog/#added_3","title":"Added","text":"<ul> <li>Tests from 2D straight skeleton module.</li> </ul>"},{"location":"changelog/#changed_3","title":"Changed","text":"<ul> <li>Added polygon with holes offset test.</li> </ul>"},{"location":"changelog/#removed_3","title":"Removed","text":"<ul> <li>Profiling dependency and decorators from examples.</li> </ul>"},{"location":"changelog/#077-2025-03-20","title":"[0.7.7] 2025-03-20","text":""},{"location":"changelog/#added_4","title":"Added","text":"<ul> <li>Added GitHub release action.</li> </ul>"},{"location":"changelog/#changed_4","title":"Changed","text":"<ul> <li>Split binding into separate dynamic libraries.</li> <li>The documentation contribution guide has been updated based on the single-file and single dynamic library build process.</li> <li>Example images in the documentation have been updated.</li> <li>The Python/C++ module name has been changed from <code>name_ext</code> to <code>_name</code>.</li> </ul>"},{"location":"changelog/#removed_4","title":"Removed","text":""},{"location":"changelog/#076-2025-03-19","title":"[0.7.6] 2025-03-19","text":""},{"location":"changelog/#added_5","title":"Added","text":""},{"location":"changelog/#changed_5","title":"Changed","text":"<ul> <li>Temp remove reconstruction and 2D skeleton to fix memory problems during conda build for windows.</li> </ul>"},{"location":"changelog/#removed_5","title":"Removed","text":""},{"location":"changelog/#075-2025-03-19","title":"[0.7.5] 2025-03-19","text":""},{"location":"changelog/#added_6","title":"Added","text":""},{"location":"changelog/#changed_6","title":"Changed","text":""},{"location":"changelog/#removed_6","title":"Removed","text":""},{"location":"changelog/#074-2025-03-19","title":"[0.7.4] 2025-03-19","text":""},{"location":"changelog/#added_7","title":"Added","text":"<ul> <li>Added build flags for file size reduction in <code>CMakeLists.txt</code>.</li> </ul>"},{"location":"changelog/#changed_7","title":"Changed","text":"<ul> <li>Precompiled header is optional and set to OFF to reduce deployment built size.</li> <li>Moved <code>compas.h</code> module specific headers to the individual source files.</li> </ul>"},{"location":"changelog/#removed_7","title":"Removed","text":"<ul> <li>Remove unnecessary headers from <code>compas_cgal.h</code>.</li> <li>Remove <code>reconstruction.h</code> and <code>reconstruction.cpp</code>.</li> <li>Remove <code>straight_skeleton_2.h</code> and <code>straight_skeleton_2.cpp</code>.</li> </ul>"},{"location":"changelog/#073-2025-03-18","title":"[0.7.3] 2025-03-18","text":""},{"location":"changelog/#added_8","title":"Added","text":""},{"location":"changelog/#changed_8","title":"Changed","text":"<ul> <li>Nanobind integration.</li> </ul>"},{"location":"changelog/#removed_8","title":"Removed","text":"<ul> <li>Files related to pybind11.</li> </ul>"},{"location":"changelog/#072-2024-10-29","title":"[0.7.2] 2024-10-29","text":""},{"location":"changelog/#added_9","title":"Added","text":"<ul> <li>Added recipe hasher.</li> <li>Added <code>scip</code> to dev install instructions in README.md</li> <li>Added <code>compas_cgal.straight_skeleton_2.offset_polygon_with_holes</code>.</li> </ul>"},{"location":"changelog/#changed_9","title":"Changed","text":"<ul> <li>Changed name of <code>compas_cgal.straight_skeleton_2.create_interior_straight_skeleton</code> to <code>interior_straight_skeleton</code></li> <li>Changed name of <code>compas_cgal.straight_skeleton_2.create_interior_straight_skeleton_with_holes</code> to <code>interior_straight_skeleton_with_holes</code></li> <li>Changed name of <code>compas_cgal.straight_skeleton_2.create_offset_polygons_2</code> to <code>offset_polygon</code></li> <li>Changed name of <code>compas_cgal.straight_skeleton_2.create_weighted_offset_polygons_2</code> to <code>weighted_offset_polygon</code></li> <li>Changed version to <code>scip=9.0.0</code> for windows.</li> </ul>"},{"location":"changelog/#removed_9","title":"Removed","text":"<ul> <li>Removed optional support for GLPK for polygonal surface reconstruction.</li> </ul>"},{"location":"changelog/#071-2024-09-26","title":"[0.7.1] 2024-09-26","text":""},{"location":"changelog/#added_10","title":"Added","text":""},{"location":"changelog/#changed_10","title":"Changed","text":"<ul> <li>Changed the return values of <code>compas_cgal.straight_skeleton_2.create_interior_straight_skeleton</code> and <code>compas_cgal.straight_skeleton_2.create_interior_straight_skeleton_with_holes</code>.</li> <li>Changed the return values of <code>compas_cgal.create_interior_straight_skeleton</code>.</li> </ul>"},{"location":"changelog/#removed_10","title":"Removed","text":""},{"location":"changelog/#070-2024-05-14","title":"[0.7.0] 2024-05-14","text":""},{"location":"changelog/#added_11","title":"Added","text":"<ul> <li>Added <code>compas_cgal.straight_skeleton_2.create_interior_straight_skeleton</code>.</li> <li>Added <code>compas_cgal.straight_skeleton_2.create_interior_straight_skeleton_with_holes</code>.</li> <li>Added <code>compas_cgal.straight_skeleton_2.create_offset_polygons_2_inner</code>.</li> <li>Added <code>compas_cgal.straight_skeleton_2.create_offset_polygons_2_outer</code>.</li> <li>Added <code>compas_cgal.straight_skeleton_2.create_weighted_offset_polygons_2_inner</code>.</li> <li>Added <code>compas_cgal.straight_skeleton_2.create_weighted_offset_polygons_2_outer</code>.</li> </ul>"},{"location":"changelog/#changed_11","title":"Changed","text":""},{"location":"changelog/#removed_11","title":"Removed","text":""},{"location":"changelog/#060-2024-02-01","title":"[0.6.0] 2024-02-01","text":""},{"location":"changelog/#added_12","title":"Added","text":"<ul> <li>Added <code>compas_cgal.reconstruction.poission_surface_reconstruction</code>.</li> <li>Added <code>compas_cgal.reconstruction.pointset_outlier_removal</code>.</li> <li>Added <code>compas_cgal.reconstruction.pointset_reduction</code>.</li> <li>Added <code>compas_cgal.reconstruction.pointset_smoothing</code>.</li> <li>Added <code>compas_cgal.reconstruction.pointset_normal_estimation</code>.</li> <li>Added <code>compas_cgal.skeletonization.mesh_skeleton</code>.</li> <li>Added <code>compas_cgal.subdivision.mesh_subdivision_catmull_clark</code>.</li> <li>Added <code>compas_cgal.subdivision.mesh_subdivision_loop</code>.</li> <li>Added <code>compas_cgal.subdivision.mesh_subdivision_sqrt3</code>.</li> <li>Added <code>compas_cgal.triangulation.refined_delaunay_mesh</code>.</li> </ul>"},{"location":"changelog/#changed_12","title":"Changed","text":"<ul> <li>Moved main include types like <code>Point</code>, <code>Vector</code>, <code>Polyline</code> and etc. to the <code>compas</code> namespace.</li> </ul>"},{"location":"changelog/#removed_12","title":"Removed","text":""},{"location":"changelog/#050-2022-10-07","title":"[0.5.0] 2022-10-07","text":""},{"location":"changelog/#added_13","title":"Added","text":"<ul> <li>Support to python 3.10.</li> <li>Added Changelog check in PRs.</li> <li>Exposing mesh <code>compas_cgal.booleans.split</code> function.</li> </ul>"},{"location":"changelog/#changed_13","title":"Changed","text":"<ul> <li>Updated github workflow.</li> </ul>"},{"location":"changelog/#removed_13","title":"Removed","text":""},{"location":"changelog/#040-2022-01-20","title":"[0.4.0] 2022-01-20","text":""},{"location":"changelog/#added_14","title":"Added","text":"<ul> <li>Added type annotations.</li> <li>Added dimension checks to trimesh setters.</li> <li>Added <code>compas_cgal.measure.volume</code>.</li> <li>Added <code>compas_cgal.subdivision.catmull_clark</code>.</li> </ul>"},{"location":"changelog/#changed_14","title":"Changed","text":""},{"location":"changelog/#removed_14","title":"Removed","text":""},{"location":"changelog/#030-2021-12-14","title":"[0.3.0] 2021-12-14","text":""},{"location":"changelog/#added_15","title":"Added","text":"<ul> <li>Added <code>compas_cgal.booleans.boolean_union</code>.</li> <li>Added <code>compas_cgal.booleans.boolean_difference</code>.</li> <li>Added <code>compas_cgal.booleans.boolean_intersection</code>.</li> <li>Added <code>compas_cgal.intersections.intersection_mesh_mesh</code>.</li> <li>Added <code>compas_cgal.meshing.remesh</code>.</li> <li>Added <code>compas_cgal.slicer.slice_mesh</code>.</li> <li>Added <code>compas_cgal.triangulation.delaunay_triangulation</code>.</li> <li>Added <code>compas_cgal.triangulation.constrained_delaunay_triangulation</code>.</li> <li>Added <code>compas_cgal.triangulation.conforming_delaunay_triangulation</code>.</li> </ul>"},{"location":"changelog/#changed_15","title":"Changed","text":""},{"location":"changelog/#removed_15","title":"Removed","text":""},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#stable","title":"Stable","text":"<p>Stable releases of :mod:<code>compas_cgal</code> can be installed via <code>conda-forge</code>.</p> <pre><code>conda create -n cgal -c conda-forge compas_cgal\n</code></pre> <p>Several examples use the COMPAS Viewer for visualisation. To install <code>compas_viewer</code> in the same environment</p> <pre><code>conda activate cgal\nconda install compas_viewer\n</code></pre>"},{"location":"installation/#dev-install","title":"Dev Install","text":"<p>See the developer guide.</p>"},{"location":"license/","title":"License","text":"<pre><code>               GNU LESSER GENERAL PUBLIC LICENSE\n                   Version 3, 29 June 2007\n</code></pre> <p>Copyright (C) 2007 Free Software Foundation, Inc. https://fsf.org/  Everyone is permitted to copy and distribute verbatim copies  of this license document, but changing it is not allowed.</p> <p>This version of the GNU Lesser General Public License incorporates the terms and conditions of version 3 of the GNU General Public License, supplemented by the additional permissions listed below.</p> <ol> <li>Additional Definitions.</li> </ol> <p>As used herein, \"this License\" refers to version 3 of the GNU Lesser General Public License, and the \"GNU GPL\" refers to version 3 of the GNU General Public License.</p> <p>\"The Library\" refers to a covered work governed by this License, other than an Application or a Combined Work as defined below.</p> <p>An \"Application\" is any work that makes use of an interface provided by the Library, but which is not otherwise based on the Library. Defining a subclass of a class defined by the Library is deemed a mode of using an interface provided by the Library.</p> <p>A \"Combined Work\" is a work produced by combining or linking an Application with the Library.  The particular version of the Library with which the Combined Work was made is also called the \"Linked Version\".</p> <p>The \"Minimal Corresponding Source\" for a Combined Work means the Corresponding Source for the Combined Work, excluding any source code for portions of the Combined Work that, considered in isolation, are based on the Application, and not on the Linked Version.</p> <p>The \"Corresponding Application Code\" for a Combined Work means the object code and/or source code for the Application, including any data and utility programs needed for reproducing the Combined Work from the Application, but excluding the System Libraries of the Combined Work.</p> <ol> <li>Exception to Section 3 of the GNU GPL.</li> </ol> <p>You may convey a covered work under sections 3 and 4 of this License without being bound by section 3 of the GNU GPL.</p> <ol> <li>Conveying Modified Versions.</li> </ol> <p>If you modify a copy of the Library, and, in your modifications, a facility refers to a function or data to be supplied by an Application that uses the facility (other than as an argument passed when the facility is invoked), then you may convey a copy of the modified version:</p> <p>a) under this License, provided that you make a good faith effort to    ensure that, in the event an Application does not supply the    function or data, the facility still operates, and performs    whatever part of its purpose remains meaningful, or</p> <p>b) under the GNU GPL, with none of the additional permissions of    this License applicable to that copy.</p> <ol> <li>Object Code Incorporating Material from Library Header Files.</li> </ol> <p>The object code form of an Application may incorporate material from a header file that is part of the Library.  You may convey such object code under terms of your choice, provided that, if the incorporated material is not limited to numerical parameters, data structure layouts and accessors, or small macros, inline functions and templates (ten or fewer lines in length), you do both of the following:</p> <p>a) Give prominent notice with each copy of the object code that the    Library is used in it and that the Library and its use are    covered by this License.</p> <p>b) Accompany the object code with a copy of the GNU GPL and this license    document.</p> <ol> <li>Combined Works.</li> </ol> <p>You may convey a Combined Work under terms of your choice that, taken together, effectively do not restrict modification of the portions of the Library contained in the Combined Work and reverse engineering for debugging such modifications, if you also do each of the following:</p> <p>a) Give prominent notice with each copy of the Combined Work that    the Library is used in it and that the Library and its use are    covered by this License.</p> <p>b) Accompany the Combined Work with a copy of the GNU GPL and this license    document.</p> <p>c) For a Combined Work that displays copyright notices during    execution, include the copyright notice for the Library among    these notices, as well as a reference directing the user to the    copies of the GNU GPL and this license document.</p> <p>d) Do one of the following:</p> <pre><code>   0) Convey the Minimal Corresponding Source under the terms of this\n   License, and the Corresponding Application Code in a form\n   suitable for, and under terms that permit, the user to\n   recombine or relink the Application with a modified version of\n   the Linked Version to produce a modified Combined Work, in the\n   manner specified by section 6 of the GNU GPL for conveying\n   Corresponding Source.\n\n   1) Use a suitable shared library mechanism for linking with the\n   Library.  A suitable mechanism is one that (a) uses at run time\n   a copy of the Library already present on the user's computer\n   system, and (b) will operate properly with a modified version\n   of the Library that is interface-compatible with the Linked\n   Version.\n</code></pre> <p>e) Provide Installation Information, but only if you would otherwise    be required to provide such information under section 6 of the    GNU GPL, and only to the extent that such information is    necessary to install and execute a modified version of the    Combined Work produced by recombining or relinking the    Application with a modified version of the Linked Version. (If    you use option 4d0, the Installation Information must accompany    the Minimal Corresponding Source and Corresponding Application    Code. If you use option 4d1, you must provide the Installation    Information in the manner specified by section 6 of the GNU GPL    for conveying Corresponding Source.)</p> <ol> <li>Combined Libraries.</li> </ol> <p>You may place library facilities that are a work based on the Library side by side in a single library together with other library facilities that are not Applications and are not covered by this License, and convey such a combined library under terms of your choice, if you do both of the following:</p> <p>a) Accompany the combined library with a copy of the same work based    on the Library, uncombined with any other library facilities,    conveyed under the terms of this License.</p> <p>b) Give prominent notice with the combined library that part of it    is a work based on the Library, and explaining where to find the    accompanying uncombined form of the same work.</p> <ol> <li>Revised Versions of the GNU Lesser General Public License.</li> </ol> <p>The Free Software Foundation may publish revised and/or new versions of the GNU Lesser General Public License from time to time. Such new versions will be similar in spirit to the present version, but may differ in detail to address new problems or concerns.</p> <p>Each version is given a distinguishing version number. If the Library as you received it specifies that a certain numbered version of the GNU Lesser General Public License \"or any later version\" applies to it, you have the option of following the terms and conditions either of that published version or of any later version published by the Free Software Foundation. If the Library as you received it does not specify a version number of the GNU Lesser General Public License, you may choose any version of the GNU Lesser General Public License ever published by the Free Software Foundation.</p> <p>If the Library as you received it specifies that a proxy can decide whether future versions of the GNU Lesser General Public License shall apply, that proxy's public statement of acceptance of any version is permanent authorization for you to choose that version for the Library.</p>"},{"location":"api/compas_cgal.booleans/","title":"compas_cgal.booleans","text":""},{"location":"api/compas_cgal.booleans/#compas_cgal.booleans","title":"compas_cgal.booleans","text":""},{"location":"api/compas_cgal.booleans/#compas_cgal.booleans-functions","title":"Functions","text":""},{"location":"api/compas_cgal.booleans/#compas_cgal.booleans.boolean_difference_mesh_mesh","title":"boolean_difference_mesh_mesh","text":"<pre><code>boolean_difference_mesh_mesh(A: VerticesFaces, B: VerticesFaces) -&gt; VerticesFacesNumpy\n</code></pre> <p>Boolean difference of two meshes.</p> <p>Parameters:</p> Name Type Description Default <code>A</code> <code>VerticesFaces</code> <p>Mesh A.</p> required <code>B</code> <code>VerticesFaces</code> <p>Mesh B.</p> required <p>Returns:</p> Type Description <code>VerticesFacesNumpy</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from compas.geometry import Box, Sphere, Polyhedron\n&gt;&gt;&gt; from compas_cgal.booleans import boolean_difference_mesh_mesh\n</code></pre> <pre><code>&gt;&gt;&gt; box = Box(1)\n&gt;&gt;&gt; sphere = Sphere(0.5, point=[1, 1, 1])\n</code></pre> <pre><code>&gt;&gt;&gt; A = box.to_vertices_and_faces(triangulated=True)\n&gt;&gt;&gt; B = sphere.to_vertices_and_faces(u=32, v=32, triangulated=True)\n</code></pre> <pre><code>&gt;&gt;&gt; C = boolean_difference_mesh_mesh(A, B)\n&gt;&gt;&gt; shape = Polyhedron(*C)\n</code></pre>"},{"location":"api/compas_cgal.booleans/#compas_cgal.booleans.boolean_intersection_mesh_mesh","title":"boolean_intersection_mesh_mesh","text":"<pre><code>boolean_intersection_mesh_mesh(\n    A: VerticesFaces, B: VerticesFaces\n) -&gt; VerticesFacesNumpy\n</code></pre> <p>Boolean intersection of two meshes.</p> <p>Parameters:</p> Name Type Description Default <code>A</code> <code>VerticesFaces</code> <p>Mesh A.</p> required <code>B</code> <code>VerticesFaces</code> <p>Mesh B.</p> required <p>Returns:</p> Type Description <code>VerticesFacesNumpy</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from compas.geometry import Box, Sphere, Polyhedron\n&gt;&gt;&gt; from compas_cgal.booleans import boolean_intersection_mesh_mesh\n</code></pre> <pre><code>&gt;&gt;&gt; box = Box(1)\n&gt;&gt;&gt; sphere = Sphere(0.5, point=[1, 1, 1])\n</code></pre> <pre><code>&gt;&gt;&gt; A = box.to_vertices_and_faces(triangulated=True)\n&gt;&gt;&gt; B = sphere.to_vertices_and_faces(u=32, v=32, triangulated=True)\n</code></pre> <pre><code>&gt;&gt;&gt; C = boolean_intersection_mesh_mesh(A, B)\n&gt;&gt;&gt; shape = Polyhedron(*C)\n</code></pre>"},{"location":"api/compas_cgal.booleans/#compas_cgal.booleans.boolean_union_mesh_mesh","title":"boolean_union_mesh_mesh","text":"<pre><code>boolean_union_mesh_mesh(A: VerticesFaces, B: VerticesFaces) -&gt; VerticesFacesNumpy\n</code></pre> <p>Boolean union of two meshes.</p> <p>Parameters:</p> Name Type Description Default <code>A</code> <code>VerticesFaces</code> <p>Mesh A.</p> required <code>B</code> <code>VerticesFaces</code> <p>Mesh B.</p> required <p>Returns:</p> Type Description <code>VerticesFacesNumpy</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from compas.geometry import Box, Sphere, Polyhedron\n&gt;&gt;&gt; from compas_cgal.booleans import boolean_union_mesh_mesh\n</code></pre> <pre><code>&gt;&gt;&gt; box = Box(1)\n&gt;&gt;&gt; sphere = Sphere(0.5, point=[1, 1, 1])\n</code></pre> <pre><code>&gt;&gt;&gt; A = box.to_vertices_and_faces(triangulated=True)\n&gt;&gt;&gt; B = sphere.to_vertices_and_faces(u=32, v=32, triangulated=True)\n</code></pre> <pre><code>&gt;&gt;&gt; C = boolean_union_mesh_mesh(A, B)\n&gt;&gt;&gt; shape = Polyhedron(*C)\n</code></pre>"},{"location":"api/compas_cgal.booleans/#compas_cgal.booleans.split_mesh_mesh","title":"split_mesh_mesh","text":"<pre><code>split_mesh_mesh(A: VerticesFaces, B: VerticesFaces) -&gt; VerticesFacesNumpy\n</code></pre> <p>Split one mesh with another.</p> <p>Parameters:</p> Name Type Description Default <code>A</code> <code>VerticesFaces</code> <p>Mesh A.</p> required <code>B</code> <code>VerticesFaces</code> <p>Mesh B.</p> required <p>Returns:</p> Type Description <code>VerticesFacesNumpy</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from compas.geometry import Box, Sphere, Polyhedron\n&gt;&gt;&gt; from compas_cgal.booleans import split_mesh_mesh\n</code></pre> <pre><code>&gt;&gt;&gt; box = Box(1)\n&gt;&gt;&gt; sphere = Sphere(0.5, point=[1, 1, 1])\n</code></pre> <pre><code>&gt;&gt;&gt; A = box.to_vertices_and_faces(triangulated=True)\n&gt;&gt;&gt; B = sphere.to_vertices_and_faces(u=32, v=32, triangulated=True)\n</code></pre> <pre><code>&gt;&gt;&gt; V, F = split_mesh_mesh(A, B)\n&gt;&gt;&gt; shape = Polyhedron(V.tolist(), F.tolist())\n</code></pre>"},{"location":"api/compas_cgal.intersections/","title":"compas_cgal.intersections","text":""},{"location":"api/compas_cgal.intersections/#compas_cgal.intersections","title":"compas_cgal.intersections","text":""},{"location":"api/compas_cgal.intersections/#compas_cgal.intersections-functions","title":"Functions","text":""},{"location":"api/compas_cgal.intersections/#compas_cgal.intersections.intersection_mesh_mesh","title":"intersection_mesh_mesh","text":"<pre><code>intersection_mesh_mesh(A: VerticesFaces, B: VerticesFaces) -&gt; PolylinesNumpy\n</code></pre> <p>Compute the intersection of tow meshes.</p> <p>Parameters:</p> Name Type Description Default <code>A</code> <code>VerticesFaces</code> <p>Mesh A.</p> required <code>B</code> <code>VerticesFaces</code> <p>Mesh B.</p> required <p>Returns:</p> Type Description <code>PolylinesNumpy</code> <p>A list of intersection polylines, with each polyline an array of points.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from compas.geometry import Box, Sphere, Polyline\n&gt;&gt;&gt; from compas_cgal.intersections import intersection_mesh_mesh\n</code></pre> <pre><code>&gt;&gt;&gt; box = Box(1)\n&gt;&gt;&gt; sphere = Sphere(0.5, point=[1, 1, 1])\n</code></pre> <pre><code>&gt;&gt;&gt; A = box.to_vertices_and_faces(triangulated=True)\n&gt;&gt;&gt; B = sphere.to_vertices_and_faces(u=32, v=32, triangulated=True)\n</code></pre> <pre><code>&gt;&gt;&gt; result = intersection_mesh_mesh(A, B)\n&gt;&gt;&gt; polylines = [Polyline(points) for points in result]\n</code></pre>"},{"location":"api/compas_cgal.measure/","title":"compas_cgal.measure","text":""},{"location":"api/compas_cgal.measure/#compas_cgal.measure","title":"compas_cgal.measure","text":""},{"location":"api/compas_cgal.measure/#compas_cgal.measure-functions","title":"Functions","text":""},{"location":"api/compas_cgal.measure/#compas_cgal.measure.mesh_area","title":"mesh_area","text":"<pre><code>mesh_area(mesh: VerticesFaces) -&gt; float\n</code></pre> <p>Compute the area of a triangle mesh.</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>VerticesFaces</code> <p>The mesh.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The area of the mesh.</p>"},{"location":"api/compas_cgal.measure/#compas_cgal.measure.mesh_centroid","title":"mesh_centroid","text":"<pre><code>mesh_centroid(mesh: VerticesFaces) -&gt; list[float]\n</code></pre> <p>Compute the centroid of a the volume of a closed triangle mesh.</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>VerticesFaces</code> <p>The mesh.</p> required <p>Returns:</p> Type Description <code>list[float]</code> <p>The centroid of the mesh.</p>"},{"location":"api/compas_cgal.measure/#compas_cgal.measure.mesh_volume","title":"mesh_volume","text":"<pre><code>mesh_volume(mesh: VerticesFaces) -&gt; float\n</code></pre> <p>Compute the volume of a closed triangle mesh.</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>VerticesFaces</code> <p>The mesh.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The volume of the mesh.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from compas.geometry import Box\n&gt;&gt;&gt; from compas_cgal.measure import mesh_volume\n</code></pre> <pre><code>&gt;&gt;&gt; box = Box(1)\n&gt;&gt;&gt; mesh = box.to_vertices_and_faces(triangulated=True)\n</code></pre> <pre><code>&gt;&gt;&gt; mesh_volume(mesh)\n1.0\n</code></pre>"},{"location":"api/compas_cgal.meshing/","title":"compas_cgal.meshing","text":""},{"location":"api/compas_cgal.meshing/#compas_cgal.meshing","title":"compas_cgal.meshing","text":""},{"location":"api/compas_cgal.meshing/#compas_cgal.meshing-functions","title":"Functions","text":""},{"location":"api/compas_cgal.meshing/#compas_cgal.meshing.trimesh_dual","title":"trimesh_dual","text":"<pre><code>trimesh_dual(\n    mesh: VerticesFaces,\n    length_factor: float = 1.0,\n    number_of_iterations: int = 10,\n    angle_radians: float = 0.9,\n    scale_factor: float = 1.0,\n    fixed_vertices: list[int] = [],\n) -&gt; tuple[ndarray, list[list[int]]]\n</code></pre> <p>Create a dual mesh from a triangular mesh with variable-length faces.</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>VerticesFaces</code> <p>The mesh to create a dual from.</p> required <code>angle_radians</code> <code>float</code> <p>Angle limit in radians for boundary vertices to remove.</p> <code>0.9</code> <code>length_factor</code> <code>float</code> <p>Length factor for remeshing.</p> <code>1.0</code> <code>number_of_iterations</code> <code>int</code> <p>Number of remeshing iterations.</p> <code>10</code> <code>scale_factor</code> <code>float</code> <p>Scale factor for inner vertices.</p> <code>1.0</code> <code>fixed_vertices</code> <code>list[int]</code> <p>List of vertex indices to keep fixed during remeshing.</p> <code>[]</code> <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple containing:</p> <ul> <li>Remeshed mesh vertices as an Nx3 numpy array.</li> <li>Remeshed mesh faces as an Mx3 numpy array.</li> <li>Dual mesh vertices as an Nx3 numpy array.</li> <li>Variable-length faces as a list of lists of vertex indices.</li> </ul> Notes <p>This dual mesh implementation includes proper boundary handling by: 1. Creating vertices at face centroids of the primal mesh 2. Creating additional vertices at boundary edge midpoints 3. Creating proper connections for boundary edges</p>"},{"location":"api/compas_cgal.meshing/#compas_cgal.meshing.trimesh_remesh","title":"trimesh_remesh","text":"<pre><code>trimesh_remesh(\n    mesh: VerticesFaces,\n    target_edge_length: float,\n    number_of_iterations: int = 10,\n    do_project: bool = True,\n) -&gt; VerticesFacesNumpy\n</code></pre> <p>Remeshing of a triangle mesh.</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>VerticesFaces</code> <p>The mesh to remesh.</p> required <code>target_edge_length</code> <code>float</code> <p>The target edge length.</p> required <code>number_of_iterations</code> <code>int</code> <p>Number of remeshing iterations.</p> <code>10</code> <code>do_project</code> <code>bool</code> <p>If True, reproject vertices onto the input surface when they are created or displaced.</p> <code>True</code> <p>Returns:</p> Type Description <code>VerticesFacesNumpy</code> Notes <p>This remeshing function only constrains the edges on the boundary of the mesh. Protecting specific features or edges is not implemented yet.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from compas.geometry import Sphere, Polyhedron\n&gt;&gt;&gt; from compas_cgal.meshing import mesh_remesh\n</code></pre> <pre><code>&gt;&gt;&gt; sphere = Sphere(0.5, point=[1, 1, 1])\n&gt;&gt;&gt; mesh = sphere.to_vertices_and_faces(u=32, v=32, triangulated=True)\n</code></pre> <pre><code>&gt;&gt;&gt; V, F = mesh_remesh(mesh, 1.0)\n&gt;&gt;&gt; shape = Polyhedron(V.tolist(), F.tolist())\n</code></pre>"},{"location":"api/compas_cgal.projection/","title":"compas_cgal.projection","text":""},{"location":"api/compas_cgal.projection/#compas_cgal.projection","title":"compas_cgal.projection","text":""},{"location":"api/compas_cgal.projection/#compas_cgal.projection-functions","title":"Functions","text":""},{"location":"api/compas_cgal.projection/#compas_cgal.projection.project_mesh_on_mesh","title":"project_mesh_on_mesh","text":"<pre><code>project_mesh_on_mesh(\n    mesh_source: VerticesFaces, mesh_target: VerticesFaces\n) -&gt; VerticesFaces\n</code></pre> <p>Project mesh_source vertices onto mesh_target surface.</p> <p>Parameters:</p> Name Type Description Default <code>mesh_source</code> <code>:attr:`compas_cgal.types.VerticesFaces`</code> <p>Mesh that is projected onto the target mesh.</p> required <code>mesh_target</code> <code>:attr:`compas_cgal.types.VerticesFaces`</code> <p>Mesh that is projected onto.</p> required <p>Returns:</p> Type Description <code>attr:`compas_cgal.types.VerticesFaces`</code> <p>The projected mesh (vertices on mesh_source surface, original faces).</p>"},{"location":"api/compas_cgal.projection/#compas_cgal.projection.project_points_on_mesh","title":"project_points_on_mesh","text":"<pre><code>project_points_on_mesh(\n    points: list[list[float]], mesh: VerticesFaces\n) -&gt; list[list[float]]\n</code></pre> <p>Project points onto a mesh by closest perpendicular distance.</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>list[list[float]]</code> <p>The points to project.</p> required <code>mesh</code> <code>:attr:`compas_cgal.types.VerticesFaces`</code> <p>Mesh that the points are projected onto.</p> required <p>Returns:</p> Type Description <code>list[list[float]]</code> <p>The projected points (vertices on the mesh surface).</p>"},{"location":"api/compas_cgal.projection/#compas_cgal.projection.pull_mesh_on_mesh","title":"pull_mesh_on_mesh","text":"<pre><code>pull_mesh_on_mesh(\n    mesh_source: VerticesFaces, mesh_target: VerticesFaces\n) -&gt; VerticesFaces\n</code></pre> <p>Pull mesh_source vertices onto mesh_target surface using mesh_source normals.</p> <p>Parameters:</p> Name Type Description Default <code>mesh_source</code> <code>:attr:`compas_cgal.types.VerticesFaces`</code> <p>Mesh that is projected onto the target mesh.</p> required <code>mesh_target</code> <code>:attr:`compas_cgal.types.VerticesFaces`</code> <p>Mesh that is projected onto.</p> required <p>Returns:</p> Type Description <code>attr:`compas_cgal.types.VerticesFaces`</code> <p>The projected mesh (vertices on mesh_source surface, original faces).</p>"},{"location":"api/compas_cgal.projection/#compas_cgal.projection.pull_points_on_mesh","title":"pull_points_on_mesh","text":"<pre><code>pull_points_on_mesh(\n    points: list[list[float]], normals: list[list[float]], mesh: VerticesFaces\n) -&gt; list[list[float]]\n</code></pre> <p>Pull points onto a mesh surface using ray-mesh intersection along normal vectors.</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>list[list[float]]</code> <p>The points to pull.</p> required <code>normals</code> <code>list[list[float]]</code> <p>The normal vectors used for directing the projection.</p> required <code>mesh</code> <code>:attr:`compas_cgal.types.VerticesFaces`</code> <p>Mesh that the points are pulled onto.</p> required <p>Returns:</p> Type Description <code>list[list[float]]</code> <p>The pulled points (vertices on the mesh surface).</p>"},{"location":"api/compas_cgal.reconstruction/","title":"compas_cgal.reconstruction","text":""},{"location":"api/compas_cgal.reconstruction/#compas_cgal.reconstruction","title":"compas_cgal.reconstruction","text":""},{"location":"api/compas_cgal.reconstruction/#compas_cgal.reconstruction-functions","title":"Functions","text":""},{"location":"api/compas_cgal.reconstruction/#compas_cgal.reconstruction.pointset_normal_estimation","title":"pointset_normal_estimation","text":"<pre><code>pointset_normal_estimation(\n    points: list[Point] | FloatNx3, neighbors: int = 8, erase: bool = False\n) -&gt; tuple[FloatNx3, FloatNx3]\n</code></pre> <p>Remove outliers from a point cloud using the point set outlier removal algorithm.</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>list[Point] | FloatNx3</code> <p>The points of the point cloud.</p> required <code>neighbors</code> <code>int</code> <p>The number of nearest neighbors to consider for each point.</p> <code>8</code> <code>erase</code> <code>bool</code> <p>Erase points that are not oriented properly.</p> <code>False</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>The vectors of the point cloud.</p>"},{"location":"api/compas_cgal.reconstruction/#compas_cgal.reconstruction.pointset_outlier_removal","title":"pointset_outlier_removal","text":"<pre><code>pointset_outlier_removal(\n    points: list[Point] | FloatNx3, nnnbrs: int = 10, radius: float = 1.0\n) -&gt; FloatNx3\n</code></pre> <p>Remove outliers from a point cloud using the point set outlier removal algorithm.</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>list[Point] | FloatNx3</code> <p>The points of the point cloud.</p> required <code>nnnbrs</code> <code>int</code> <p>The number of nearest neighbors to consider for each point.</p> <code>10</code> <code>radius</code> <code>float</code> <p>The radius of the sphere to consider for each point as a multiplication factor of the average point spacing.</p> <code>1.0</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>The points of the point cloud without outliers.</p>"},{"location":"api/compas_cgal.reconstruction/#compas_cgal.reconstruction.pointset_reduction","title":"pointset_reduction","text":"<pre><code>pointset_reduction(points: list[Point] | FloatNx3, spacing: float = 2) -&gt; FloatNx3\n</code></pre> <p>Remove outliers from a point cloud using the point set outlier removal algorithm.</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>list[Point] | FloatNx3</code> <p>The points of the point cloud.</p> required <code>spacing</code> <code>float</code> <p>The cell size.</p> <code>2</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>The vectors of the point cloud.</p>"},{"location":"api/compas_cgal.reconstruction/#compas_cgal.reconstruction.pointset_smoothing","title":"pointset_smoothing","text":"<pre><code>pointset_smoothing(\n    points: list[Point] | FloatNx3, neighbors: int = 8, iterations: int = 1\n) -&gt; FloatNx3\n</code></pre> <p>Remove outliers from a point cloud using the point set outlier removal algorithm.</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>list[Point] | FloatNx3</code> <p>The points of the point cloud.</p> required <code>neighbors</code> <code>int</code> <p>The number of nearest neighbors to consider for each point.</p> <code>8</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>The vectors of the point cloud.</p>"},{"location":"api/compas_cgal.reconstruction/#compas_cgal.reconstruction.poisson_surface_reconstruction","title":"poisson_surface_reconstruction","text":"<pre><code>poisson_surface_reconstruction(\n    points: list[Point] | FloatNx3,\n    normals: list[Vector] | FloatNx3,\n    sm_angle: float = 20.0,\n    sm_radius: float = 30.0,\n    sm_distance: float = 0.375,\n) -&gt; tuple[FloatNx3, IntNx3]\n</code></pre> <p>Reconstruct a surface from a point cloud using the Poisson surface reconstruction algorithm.</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>list[Point] | FloatNx3</code> <p>The points of the point cloud.</p> required <code>normals</code> <code>list[Vector] | FloatNx3</code> <p>The normals of the point cloud.</p> required <code>sm_angle</code> <code>float</code> <p>Surface meshing angle bound in degrees. Controls the minimum angle of triangles in the output mesh. Default is 20.0.</p> <code>20.0</code> <code>sm_radius</code> <code>float</code> <p>Surface meshing radius bound as a factor of average spacing. Controls the size of triangles relative to the point cloud density. Larger values result in coarser meshes with fewer vertices. Default is 30.0.</p> <code>30.0</code> <code>sm_distance</code> <code>float</code> <p>Surface meshing approximation error bound as a factor of average spacing. Controls how closely the mesh approximates the implicit surface. Larger values result in coarser meshes with fewer vertices that may deviate more from the original point cloud. Default is 0.375.</p> <code>0.375</code> <p>Returns:</p> Type Description <code>tuple[ndarray]</code> <p>The vertices and faces of the reconstructed surface.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If points or normals are not 3D If number of points and normals don't match If less than 3 points are provided If points are not well-distributed for reconstruction</p> <code>RuntimeError</code> <p>If the reconstruction algorithm fails</p> Notes <p>The Poisson surface reconstruction algorithm requires: 1. A sufficiently dense point cloud 2. Well-oriented normals 3. Points distributed across a meaningful surface</p> <p>The surface meshing parameters (sm_angle, sm_radius, sm_distance) control the quality and density of the output mesh. Increasing sm_radius and sm_distance will typically result in fewer mesh vertices, which can help filter out vertices that don't belong to the original point cloud, but may also reduce detail.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; points = [[0, 0, 0], [1, 0, 0], [0, 1, 0], [0, 0, 1]]\n&gt;&gt;&gt; normals = [[0, 0, 1], [0, 0, 1], [0, 0, 1], [0, 0, 1]]\n&gt;&gt;&gt; V, F = poisson_surface_reconstruction(points, normals)\n&gt;&gt;&gt; # Use larger sm_radius and sm_distance to reduce mesh complexity\n&gt;&gt;&gt; V, F = poisson_surface_reconstruction(points, normals, sm_radius=50.0, sm_distance=0.5)\n</code></pre>"},{"location":"api/compas_cgal.skeletonization/","title":"compas_cgal.skeletonization","text":""},{"location":"api/compas_cgal.skeletonization/#compas_cgal.skeletonization","title":"compas_cgal.skeletonization","text":""},{"location":"api/compas_cgal.skeletonization/#compas_cgal.skeletonization-functions","title":"Functions","text":""},{"location":"api/compas_cgal.skeletonization/#compas_cgal.skeletonization.mesh_skeleton","title":"mesh_skeleton","text":"<pre><code>mesh_skeleton(mesh: VerticesFaces) -&gt; PolylinesNumpySkeleton\n</code></pre> <p>Compute the geometric skeleton of a triangle mesh using mean curvature flow.</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>VerticesFaces</code> <p>A tuple containing: * vertices: Nx3 array of vertex coordinates * faces: Mx3 array of vertex indices</p> required <p>Returns:</p> Type Description <code>PolylinesNumpySkeleton</code> <p>List of polylines representing the skeleton edges. Each polyline is a tuple of start and end point coordinates.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If the input mesh is not a tuple of vertices and faces.</p> <code>ValueError</code> <p>If the vertices array is not Nx3. If the faces array is not Mx3. If the face indices are out of range. If the mesh is not manifold and closed.</p> <code>RuntimeError</code> <p>If the mesh contraction fails to converge.</p> Notes <p>The input mesh must be manifold and closed. The skeleton is computed using mean curvature flow.</p>"},{"location":"api/compas_cgal.skeletonization/#compas_cgal.skeletonization.mesh_skeleton_with_mapping","title":"mesh_skeleton_with_mapping","text":"<pre><code>mesh_skeleton_with_mapping(\n    mesh: VerticesFaces,\n) -&gt; tuple[PolylinesNumpySkeleton, SkeletonVertexMapping]\n</code></pre> <p>Compute the geometric skeleton of a triangle mesh with vertex correspondence mapping.</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>VerticesFaces</code> <p>A tuple containing: * vertices: Nx3 array of vertex coordinates * faces: Mx3 array of vertex indices</p> required <p>Returns:</p> Type Description <code>PolylinesSkeletonWithMapping</code> <p>A tuple containing: * edges: List of polylines representing the skeleton edges.   Each polyline is a tuple of start and end point coordinates. * vertex_indices: List of tuples, each containing two lists of   vertex indices corresponding to the start and end vertices of   each skeleton edge. These are the original mesh vertices that   contracted to form each skeleton vertex.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If the input mesh is not a tuple of vertices and faces.</p> <code>ValueError</code> <p>If the vertices array is not Nx3. If the faces array is not Mx3. If the face indices are out of range. If the mesh is not manifold and closed.</p> <code>RuntimeError</code> <p>If the mesh contraction fails to converge.</p> Notes <p>The input mesh must be manifold and closed. The skeleton is computed using mean curvature flow. Each skeleton vertex corresponds to a set of original mesh vertices that were contracted to that point during the skeletonization process. (The set might be empty for some skeleton vertices that don't correspond to any original vertex.)</p>"},{"location":"api/compas_cgal.slicer/","title":"compas_cgal.slicer","text":""},{"location":"api/compas_cgal.slicer/#compas_cgal.slicer","title":"compas_cgal.slicer","text":""},{"location":"api/compas_cgal.slicer/#compas_cgal.slicer-functions","title":"Functions","text":""},{"location":"api/compas_cgal.slicer/#compas_cgal.slicer.slice_mesh_planes","title":"slice_mesh_planes","text":"<pre><code>slice_mesh_planes(mesh: VerticesFaces, planes: list[Plane]) -&gt; PolylinesNumpy\n</code></pre> <p>Slice a mesh by a list of planes.</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>VerticesFaces</code> <p>The mesh to slice.</p> required <code>planes</code> <code>list[Plane]</code> <p>The slicing planes.</p> required <p>Returns:</p> Type Description <code>PolylinesNumpy</code> <p>A list of slice polylines, with each polyline an array of points.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from compas.geometry import Sphere, Plane, Polyline\n&gt;&gt;&gt; from compas.itertools import linspace\n&gt;&gt;&gt; from compas_cgal.slicer import slice_mesh\n</code></pre> <pre><code>&gt;&gt;&gt; sphere = Sphere(1.0, point=[0, 0, 1.0])\n&gt;&gt;&gt; mesh = sphere.to_vertices_and_faces(u=32, v=32, triangulated=True)\n</code></pre> <pre><code>&gt;&gt;&gt; planes = [Plane([0, 0, z], [0, 0, 1.0]) for z in linspace(0.1, 1.9, 19)]\n</code></pre> <pre><code>&gt;&gt;&gt; result = slice_mesh(mesh, planes)\n&gt;&gt;&gt; polylines = [Polyline(points) for points in result]\n</code></pre>"},{"location":"api/compas_cgal.straight_skeleton_2/","title":"compas_cgal.straight_skeleton_2","text":""},{"location":"api/compas_cgal.straight_skeleton_2/#compas_cgal.straight_skeleton_2","title":"compas_cgal.straight_skeleton_2","text":""},{"location":"api/compas_cgal.straight_skeleton_2/#compas_cgal.straight_skeleton_2-functions","title":"Functions","text":""},{"location":"api/compas_cgal.straight_skeleton_2/#compas_cgal.straight_skeleton_2.graph_from_skeleton_data","title":"graph_from_skeleton_data","text":"<pre><code>graph_from_skeleton_data(\n    points: VerticesNumpy, indices: IntNx1, edges: IntNx2, edge_types: IntNx1\n) -&gt; Graph\n</code></pre> <p>Create a graph from the skeleton data.</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>VerticesNumpy</code> <p>The vertices of the skeleton, each vertex defined by 3 spatial coordinates.</p> required <code>indices</code> <code>IntNx1</code> <p>The vertex indices of the skeleton, corresponding to the points.</p> required <code>edges</code> <code>IntNx2</code> <p>The edges of the skeleton, each edge defined by 2 vertex indices.</p> required <code>edge_types</code> <code>IntNx1</code> <p>The type per edge, <code>0</code> for inner bisector, <code>1</code> for bisector, and <code>2</code> for boundary.</p> required <p>Returns:</p> Type Description <code>Graph</code> <p>The skeleton as a graph.</p>"},{"location":"api/compas_cgal.straight_skeleton_2/#compas_cgal.straight_skeleton_2.interior_straight_skeleton","title":"interior_straight_skeleton","text":"<pre><code>interior_straight_skeleton(\n    points, as_graph=True\n) -&gt; Graph | tuple[VerticesNumpy, IntNx1, IntNx2, IntNx1]\n</code></pre> <p>Compute the skeleton of a 2D polygon.</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <p>The points of the polygon.</p> required <code>as_graph</code> <p>Whether the skeleton should be returned as a graph, defaults to <code>True</code>.</p> <code>True</code> <p>Returns:</p> Type Description <code>Graph | tuple[VerticesNumpy, IntNx1, IntNx2, IntNx1]</code> <p>The skeleton of the polygon.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the normal of the polygon is not directed vertically upwards like [0, 0, 1].</p>"},{"location":"api/compas_cgal.straight_skeleton_2/#compas_cgal.straight_skeleton_2.interior_straight_skeleton_with_holes","title":"interior_straight_skeleton_with_holes","text":"<pre><code>interior_straight_skeleton_with_holes(\n    points, holes, as_graph=True\n) -&gt; Graph | tuple[VerticesNumpy, IntNx1, IntNx2, IntNx1]\n</code></pre> <p>Compute the skeleton of a 2D polygon with holes.</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <p>The points of the 2D polygon.</p> required <code>holes</code> <p>The holes of the polygon.</p> required <code>as_graph</code> <p>Whether the skeleton should be returned as a graph, defaults to <code>True</code>.</p> <code>True</code> <p>Returns:</p> Type Description <code>Graph | tuple[VerticesNumpy, IntNx1, IntNx2, IntNx1]</code> <p>The skeleton of the polygon.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the normal of the polygon is not directed vertically upwards like [0, 0, 1]. If the normal of a hole is not directed vertically downwards like [0, 0, -1].</p>"},{"location":"api/compas_cgal.straight_skeleton_2/#compas_cgal.straight_skeleton_2.offset_polygon","title":"offset_polygon","text":"<pre><code>offset_polygon(points, offset) -&gt; list[Polygon]\n</code></pre> <p>Compute the offset from a 2D polygon.</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <p>The points of the 2D polygon.</p> required <code>offset</code> <p>The offset distance. If negative, the offset is outside the polygon, otherwise inside.</p> required <p>Returns:</p> Type Description <code>list[Polygon]</code> <p>The offset polygon(s).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the normal of the polygon is not directed vertically upwards like [0, 0, 1].</p>"},{"location":"api/compas_cgal.straight_skeleton_2/#compas_cgal.straight_skeleton_2.offset_polygon_with_holes","title":"offset_polygon_with_holes","text":"<pre><code>offset_polygon_with_holes(points, holes, offset) -&gt; list[tuple[Polygon, list[Polygon]]]\n</code></pre> <p>Compute the offset from a 2D polygon with holes.</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <p>The points of the 2D polygon.</p> required <code>holes</code> <p>The holes of the polygon.</p> required <code>offset</code> <p>The offset distance. If negative, the offset is outside the polygon, otherwise inside.</p> required <p>Returns:</p> Type Description <code>list[tuple[Polygon, list[Polygon]]]</code> <p>The polygons with holes.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the normal of the polygon is not directed vertically upwards like [0, 0, 1]. If the normal of a hole is not directed vertically downwards like [0, 0, -1].</p>"},{"location":"api/compas_cgal.straight_skeleton_2/#compas_cgal.straight_skeleton_2.weighted_offset_polygon","title":"weighted_offset_polygon","text":"<pre><code>weighted_offset_polygon(points, offset, weights) -&gt; list[Polygon]\n</code></pre> <p>Compute the offset from a 2D polygon with weights.</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <p>The points of the 2D polygon.</p> required <code>offset</code> <p>The offset distance. If negative, the offset is outside the polygon, otherwise inside.</p> required <code>weights</code> <p>The weights for each edge, starting with the edge between the last and the first point.</p> required <p>Returns:</p> Type Description <code>list[Polygon]</code> <p>The offset polygon(s).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the normal of the polygon is not directed vertically upwards like [0, 0, 1].</p> <code>ValueError</code> <p>If the number of weights does not match the number of points.</p>"},{"location":"api/compas_cgal.subdivision/","title":"compas_cgal.subdivision","text":""},{"location":"api/compas_cgal.subdivision/#compas_cgal.subdivision","title":"compas_cgal.subdivision","text":""},{"location":"api/compas_cgal.subdivision/#compas_cgal.subdivision-functions","title":"Functions","text":""},{"location":"api/compas_cgal.subdivision/#compas_cgal.subdivision.mesh_subdivide_catmull_clark","title":"mesh_subdivide_catmull_clark","text":"<pre><code>mesh_subdivide_catmull_clark(mesh: VerticesFaces, k=1) -&gt; VerticesFacesNumpy\n</code></pre> <p>Subdivide a mesh with the Catmull Clark scheme.</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>VerticesFaces</code> <p>The mesh to remesh.</p> required <code>k</code> <p>The number of subdivision steps.</p> <code>1</code> <p>Returns:</p> Type Description <code>VerticesFacesNumpy</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from compas.geometry import Box, Polyhedron\n&gt;&gt;&gt; from compas_cgal.subdivision import mesh_subdivide_catmull_clark\n</code></pre> <pre><code>&gt;&gt;&gt; box = Box(1)\n&gt;&gt;&gt; mesh = box.to_vertices_and_faces()\n</code></pre> <pre><code>&gt;&gt;&gt; result = mesh_subdivide_catmull_clark(mesh, k=3)\n&gt;&gt;&gt; shape = Polyhedron(*result)\n</code></pre>"},{"location":"api/compas_cgal.subdivision/#compas_cgal.subdivision.mesh_subdivide_loop","title":"mesh_subdivide_loop","text":"<pre><code>mesh_subdivide_loop(mesh: VerticesFaces, k=1) -&gt; VerticesFacesNumpy\n</code></pre> <p>Subdivide a mesh with the Loop scheme.</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>VerticesFaces</code> <p>The mesh to remesh.</p> required <code>k</code> <p>The number of subdivision steps.</p> <code>1</code> <p>Returns:</p> Type Description <code>VerticesFacesNumpy</code>"},{"location":"api/compas_cgal.subdivision/#compas_cgal.subdivision.mesh_subdivide_sqrt3","title":"mesh_subdivide_sqrt3","text":"<pre><code>mesh_subdivide_sqrt3(mesh: VerticesFaces, k=1) -&gt; VerticesFacesNumpy\n</code></pre> <p>Subdivide a mesh with the Sqrt3 scheme.</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>VerticesFaces</code> <p>The mesh to remesh.</p> required <code>k</code> <p>The number of subdivision steps.</p> <code>1</code> <p>Returns:</p> Type Description <code>VerticesFacesNumpy</code>"},{"location":"api/compas_cgal.triangulation/","title":"compas_cgal.triangulation","text":""},{"location":"api/compas_cgal.triangulation/#compas_cgal.triangulation","title":"compas_cgal.triangulation","text":""},{"location":"api/compas_cgal.triangulation/#compas_cgal.triangulation-functions","title":"Functions","text":""},{"location":"api/compas_cgal.triangulation/#compas_cgal.triangulation.conforming_delaunay_triangulation","title":"conforming_delaunay_triangulation","text":"<pre><code>conforming_delaunay_triangulation(\n    boundary, points=None, holes=None, curves=None\n) -&gt; VerticesFacesNumpy\n</code></pre> <p>Construct a Conforming Delaunay triangulation.</p> <p>Parameters:</p> Name Type Description Default <code>boundary</code> <code>:class:`compas.geometry.Polygon`</code> <p>The boundary of the triangulation.</p> required <code>points</code> <code>list[:class:`compas.geometry.Point`]</code> <p>Additional internal points.</p> <code>None</code> <code>holes</code> <code>list[:class:`compas.geometry.Polygon`]</code> <p>Internal boundary polygons.</p> <code>None</code> <code>curves</code> <code>list[:class:`compas.geometry.Polyline`]</code> <p>Internal constraint curves.</p> <code>None</code> <p>Returns:</p> Type Description <code>attr:`compas_cgal.types.VerticesFacesNumpy`</code>"},{"location":"api/compas_cgal.triangulation/#compas_cgal.triangulation.constrained_delaunay_triangulation","title":"constrained_delaunay_triangulation","text":"<pre><code>constrained_delaunay_triangulation(\n    boundary: list[Point], points=None, holes=None, curves=None\n) -&gt; VerticesFacesNumpy\n</code></pre> <p>Construct a Constrained Delaunay triangulation.</p> <p>Parameters:</p> Name Type Description Default <code>boundary</code> <code>list[Point]</code> <p>The boundary of the triangulation.</p> required <code>points</code> <p>Additional internal points.</p> <code>None</code> <code>holes</code> <p>Internal boundary polygons.</p> <code>None</code> <code>curves</code> <p>Internal constraint curves.</p> <code>None</code> <p>Returns:</p> Type Description <code>VerticesFacesNumpy</code>"},{"location":"api/compas_cgal.triangulation/#compas_cgal.triangulation.delaunay_triangulation","title":"delaunay_triangulation","text":"<pre><code>delaunay_triangulation(points: list[Point]) -&gt; FacesNumpy\n</code></pre> <p>Construct a Delaunay triangulation from a set of points.</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>list[Point]</code> <p>Points of the triangulation.</p> required <p>Returns:</p> Type Description <code>FacesNumpy</code> <p>The faces of the triangulation.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from compas.geometry import Pointcloud\n&gt;&gt;&gt; from compas.datastructures import Mesh\n&gt;&gt;&gt; from compas_cgal.triangulation import delaunay_triangulation\n</code></pre> <pre><code>&gt;&gt;&gt; points = Pointcloud.from_bounds(8, 5, 0, 17)\n&gt;&gt;&gt; triangles = delaunay_triangulation(points)\n</code></pre> <pre><code>&gt;&gt;&gt; mesh = Mesh.from_vertices_and_faces(points, triangles)\n</code></pre>"},{"location":"api/compas_cgal.triangulation/#compas_cgal.triangulation.refined_delaunay_mesh","title":"refined_delaunay_mesh","text":"<pre><code>refined_delaunay_mesh(\n    boundary, points=None, holes=None, curves=None, maxlength=None, is_optimized=False\n) -&gt; VerticesFacesNumpy\n</code></pre> <p>Construct a refined Delaunay mesh.</p> <p>Parameters:</p> Name Type Description Default <code>boundary</code> <code>:class:`compas.geometry.Polygon`</code> <p>The boundary of the triangulation.</p> required <code>points</code> <code>list[:class:`compas.geometry.Point`]</code> <p>Additional internal points.</p> <code>None</code> <code>holes</code> <code>list[:class:`compas.geometry.Polygon`]</code> <p>Internal boundary polygons.</p> <code>None</code> <code>curves</code> <code>list[:class:`compas.geometry.Polyline`]</code> <p>Internal constraint curves.</p> <code>None</code> <code>maxlength</code> <code>float</code> <p>The maximum length of the triangle edges.</p> <code>None</code> <code>is_optimized</code> <code>bool</code> <p>Apply LLoyd's optimisation [1]_.</p> <code>False</code> <p>Returns:</p> Type Description <code>attr:`compas_cgal.types.VerticesFacesNumpy`</code> References <p>.. [1] https://doc.cgal.org/latest/Mesh_2/index.html#secMesh_2_meshes</p>"},{"location":"api/compas_cgal.types/","title":"compas_cgal.types","text":""},{"location":"api/compas_cgal.types/#compas_cgal.types","title":"compas_cgal.types","text":""},{"location":"api/compas_cgal.types/#compas_cgal.types-attributes","title":"Attributes","text":""},{"location":"api/compas_cgal.types/#compas_cgal.types.Faces","title":"Faces  <code>module-attribute</code>","text":"<pre><code>Faces = Sequence[list[int]] | IntNx3\n</code></pre> <p>The faces of a mesh, defined as an array-like sequence of faces, with each face represented by 3 vertex indices.</p>"},{"location":"api/compas_cgal.types/#compas_cgal.types.FacesNumpy","title":"FacesNumpy  <code>module-attribute</code>","text":"<pre><code>FacesNumpy = IntNx3\n</code></pre> <p>An array of faces, with each face defined by 3 vertex indices.</p>"},{"location":"api/compas_cgal.types/#compas_cgal.types.Planes","title":"Planes  <code>module-attribute</code>","text":"<pre><code>Planes = (\n    Sequence[Plane]\n    | Sequence[tuple[Point, Vector]]\n    | Sequence[tuple[list[float], list[float]]]\n)\n</code></pre> <p>A sequence of planes, with each plane defined as an actual Plane object, or as a tuple of a point and normal vector, with each point represented by a Point object or an equivalent list of coordinates, and each vector represented by a Vector object or an equivalent list of components.</p>"},{"location":"api/compas_cgal.types/#compas_cgal.types.PolylinesNumpy","title":"PolylinesNumpy  <code>module-attribute</code>","text":"<pre><code>PolylinesNumpy = list[FloatNx3]\n</code></pre> <p>A list of polylines, with each polyline represented as a Nx3 array of spatial coordinates.</p>"},{"location":"api/compas_cgal.types/#compas_cgal.types.PolylinesNumpySkeleton","title":"PolylinesNumpySkeleton  <code>module-attribute</code>","text":"<pre><code>PolylinesNumpySkeleton = list[tuple[list[float], list[float]]]\n</code></pre> <p>A list of polylines, where each polyline is represented by a tuple of start and end point coordinates.</p>"},{"location":"api/compas_cgal.types/#compas_cgal.types.SkeletonVertexMapping","title":"SkeletonVertexMapping  <code>module-attribute</code>","text":"<pre><code>SkeletonVertexMapping = list[tuple[list[int], list[int]]]\n</code></pre> <p>Vertex correspondence mapping for skeleton edges. Each tuple contains two lists: the first list has indices of original mesh vertices that contracted to the skeleton edge's start vertex, the second list has indices that contracted to the skeleton edge's end vertex.</p>"},{"location":"api/compas_cgal.types/#compas_cgal.types.Vertices","title":"Vertices  <code>module-attribute</code>","text":"<pre><code>Vertices = Sequence[list[float]] | FloatNx3\n</code></pre> <p>The vertices of a mesh, defined as an array-like sequence of vertices, with each vertex represented by 3 spatial coordinates.</p>"},{"location":"api/compas_cgal.types/#compas_cgal.types.VerticesFaces","title":"VerticesFaces  <code>module-attribute</code>","text":"<pre><code>VerticesFaces = tuple[Vertices, Faces]\n</code></pre> <p>Representation of a mesh as a tuple of vertices and faces.</p>"},{"location":"api/compas_cgal.types/#compas_cgal.types.VerticesFacesNumpy","title":"VerticesFacesNumpy  <code>module-attribute</code>","text":"<pre><code>VerticesFacesNumpy = tuple[FloatNx3, IntNx3]\n</code></pre> <p>Representation of a mesh as a tuple of vertices and faces, with the vertices represented a Nx3 array of spatial coordinates, and the faces as a Fx3 array of vertex indices.</p>"},{"location":"api/compas_cgal.types/#compas_cgal.types.VerticesNumpy","title":"VerticesNumpy  <code>module-attribute</code>","text":"<pre><code>VerticesNumpy = FloatNx3\n</code></pre> <p>An array of vertices, with each vertex defined by 3 spatial coordinates.</p>"},{"location":"examples/example_booleans/","title":"Boolean Operations","text":"<p>This example demonstrates how to perform boolean operations between two triangle meshes using COMPAS CGAL.</p> <p>The following operations are demonstrated:</p> <ul> <li>Boolean difference</li> <li>Boolean intersection</li> <li>Boolean union</li> <li>Mesh splitting</li> </ul> <pre><code>from compas.datastructures import Mesh\nfrom compas.geometry import Box\nfrom compas.geometry import Polyhedron\nfrom compas.geometry import Sphere\nfrom compas.geometry import Translation\nfrom compas_viewer import Viewer\n\nfrom compas_cgal.booleans import boolean_difference_mesh_mesh\nfrom compas_cgal.booleans import boolean_intersection_mesh_mesh\nfrom compas_cgal.booleans import boolean_union_mesh_mesh\nfrom compas_cgal.booleans import split_mesh_mesh\n\n\ndef input():\n    \"\"\"Create an input for the boolean methods.\"\"\"\n    box = Box(2)\n    A = box.to_vertices_and_faces(triangulated=True)\n    sphere = Sphere(1, point=[1, 1, 1])\n    B = sphere.to_vertices_and_faces(u=64, v=64, triangulated=True)\n    return A, B\n\n\ndef boolean_difference():\n    \"\"\"Compute the boolean difference of two triangle meshes.\"\"\"\n    A, B = input()\n    V, F = boolean_difference_mesh_mesh(A, B)\n    shape = Polyhedron(V.tolist(), F.tolist())\n    shape = shape.to_mesh()\n    return shape\n\n\ndef boolean_intersection():\n    \"\"\"Compute the boolean intersection of two triangle meshes.\"\"\"\n    A, B = input()\n    V, F = boolean_intersection_mesh_mesh(A, B)\n    shape = Polyhedron(V.tolist(), F.tolist())\n    shape = shape.to_mesh()\n    return shape\n\n\ndef boolean_union():\n    \"\"\"Compute the boolean union of two triangle meshes.\"\"\"\n    A, B = input()\n    V, F = boolean_union_mesh_mesh(A, B)\n    shape = Polyhedron(V.tolist(), F.tolist())\n    shape = shape.to_mesh()\n    return shape\n\n\ndef split():\n    \"\"\"Compute the mesh split of two triangle meshes.\"\"\"\n    A, B = input()\n    V, F = split_mesh_mesh(A, B)\n    mesh = Mesh.from_vertices_and_faces(V, F)\n    return mesh.exploded()\n\n\n# =============================================================================\n# Booleans\n# =============================================================================\n\ndifference = boolean_difference()\nintersection = boolean_intersection()\nunion = boolean_union()\nsplits = split()\n\n# =============================================================================\n# Spread\n# =============================================================================\n\ndifference.transform(Translation.from_vector([-6, 0, 0]))\nintersection.transform(Translation.from_vector([-2, 0, 0]))\nunion.transform(Translation.from_vector([2, 0, 0]))\n\nfor m in splits:\n    m.transform(Translation.from_vector([6, 0, 0]))\n\n# ==============================================================================\n# Visualize\n# ==============================================================================\n\nviewer = Viewer()\n\nviewer.scene.add(difference, lineswidth=1, show_points=False)\nviewer.scene.add(intersection, lineswidth=1, show_points=False)\nviewer.scene.add(union, lineswidth=1, show_points=False)\n\ngroup = viewer.scene.add_group(name=\"Splits\")\ngroup.add_from_list(splits, lineswidth=1, show_points=False)\n\nviewer.show()\n</code></pre>"},{"location":"examples/example_geodesics/","title":"Geodesic Distances and Isolines","text":"<p>This example demonstrates geodesic distance computation, isoline extraction, and mesh splitting using COMPAS CGAL.</p> <p>The visualization shows two rows:</p> <ul> <li>Row 1 (Single Source): Geodesic distances from a single vertex</li> <li>Row 2 (Multiple Sources): Geodesic distances from all bounding box corners</li> </ul> <p>Each row displays three columns:</p> <ul> <li>Heat Field: Mesh colored by geodesic distance (blue \u2192 red gradient) with source points marked in black</li> <li>Isolines: Extracted isoline polylines at regular distance intervals</li> <li>Split Mesh: Mesh split into components along the isolines, each colored differently</li> </ul> <p>Key Features:</p> <ul> <li>Heat method geodesic distance computation via <code>heat_geodesic_distances</code></li> <li>Reusable solver via <code>HeatGeodesicSolver</code> for multiple queries</li> <li>Isoline extraction as polylines via <code>geodesic_isolines</code></li> <li>Mesh splitting along isolines via <code>geodesic_isolines_split</code></li> </ul> <pre><code>from pathlib import Path\n\nimport numpy as np\nfrom compas.colors import Color\nfrom compas.colors import ColorMap\nfrom compas.datastructures import Mesh\nfrom compas.geometry import Box\nfrom compas.geometry import Point\nfrom compas.geometry import Polyline\nfrom compas.geometry import Translation\nfrom compas_viewer import Viewer\nfrom compas_viewer.config import Config\n\nfrom compas_cgal.geodesics import HeatGeodesicSolver\nfrom compas_cgal.geodesics import geodesic_isolines\nfrom compas_cgal.geodesics import geodesic_isolines_split\nfrom compas_cgal.geodesics import heat_geodesic_distances\n\n\ndef make_mesh(V, F, offset):\n    m = Mesh.from_vertices_and_faces(V, F)\n    m.transform(Translation.from_vector([offset[0], offset[1], 0]))\n    return m\n\n\ndef make_vertex_colors(distances):\n    return {i: cmap(d, minval=distances.min(), maxval=distances.max()) for i, d in enumerate(distances)}\n\n\ndef make_isolines(sources, offset):\n    polylines = []\n    for pts in geodesic_isolines((V, F), sources, ISOVALUES):\n        points = [[pts[i, 0] + offset[0], pts[i, 1] + offset[1], pts[i, 2]] for i in range(len(pts))]\n        polylines.append(Polyline(points))\n    return polylines\n\n\ndef make_split_meshes(sources, offset):\n    meshes = []\n    for i, (v, f) in enumerate(geodesic_isolines_split((V, F), sources, SPLIT_ISOVALUES)):\n        m = Mesh.from_vertices_and_faces(v.tolist(), f.tolist())\n        m.transform(Translation.from_vector([offset[0], offset[1], 0]))\n        meshes.append((m, COLORS[i % len(COLORS)]))\n    return meshes\n\n\ndef make_source_points(sources, offset):\n    return [Point(V[s][0] + offset[0], V[s][1] + offset[1], V[s][2]) for s in sources]\n\n\n# =============================================================================\n# Load mesh\n# =============================================================================\n\nFILE = Path(__file__).parent.parent.parent / \"data\" / \"elephant.off\"\nmesh = Mesh.from_off(FILE)\nmesh.quads_to_triangles()\nV, F = mesh.to_vertices_and_faces()\nV_np = np.array(V)\n\n# =============================================================================\n# Config\n# =============================================================================\n\nX_OFF, Y_OFF = 0.75, 1.0\nISOVALUES = [i / 50 for i in range(50)]\nSPLIT_ISOVALUES = [i / 20 for i in range(20)]\nCOLORS = [\n    Color.red(),\n    Color.orange(),\n    Color.yellow(),\n    Color.green(),\n    Color.cyan(),\n    Color.blue(),\n    Color.purple(),\n    Color.magenta(),\n]\ncmap = ColorMap.from_two_colors(Color.blue(), Color.red())\n\n# =============================================================================\n# Single sources\n# =============================================================================\n\nsrc1 = [0]\ndist1 = heat_geodesic_distances((V, F), src1)\n\n# =============================================================================\n# Multiple sources\n# =============================================================================\n\nsolver = HeatGeodesicSolver((V, F))\nbbox = Box.from_points(V_np)\nsrc2 = list(dict.fromkeys([int(np.argmin(np.linalg.norm(V_np - c, axis=1))) for c in bbox.vertices]))\ndist2 = solver.solve(src2)\n\n# =============================================================================\n# Viz\n# =============================================================================\n\nconfig = Config()\nconfig.camera.target = [X_OFF, -Y_OFF / 2, 0]\nconfig.camera.position = [X_OFF, -2.0, 0.8]\n\nviewer = Viewer(config=config)\n\n# Row 1: Single Source\n\ng1 = viewer.scene.add_group(\"Single Source\")\n\ng1.add(\n    make_mesh(V, F, (0, 0)),\n    use_vertexcolors=True,\n    vertexcolor=make_vertex_colors(dist1),\n    show_lines=False,\n)\n\nfor pt in make_source_points(src1, (0, 0)):\n    g1.add(pt, pointcolor=Color.black(), pointsize=20)\n\nfor pl in make_isolines(src1, (X_OFF, 0)):\n    g1.add(pl, linecolor=Color.red(), lineswidth=5)\n\nfor m, c in make_split_meshes(src1, (2 * X_OFF, 0)):\n    g1.add(m, facecolor=c, show_lines=False)\n\n# Row 2: Multiple Sources\n\ng2 = viewer.scene.add_group(\"Multiple Sources\")\n\ng2.add(\n    make_mesh(V, F, (0, -Y_OFF)),\n    use_vertexcolors=True,\n    vertexcolor=make_vertex_colors(dist2),\n    show_lines=False,\n)\n\nfor pt in make_source_points(src2, (0, -Y_OFF)):\n    g2.add(pt, pointcolor=Color.black(), pointsize=20)\n\nfor pl in make_isolines(src2, (X_OFF, -Y_OFF)):\n    g2.add(pl, linecolor=Color.red(), lineswidth=5)\n\nfor m, c in make_split_meshes(src2, (2 * X_OFF, -Y_OFF)):\n    g2.add(m, facecolor=c, show_lines=False)\n\nviewer.show()\n</code></pre>"},{"location":"examples/example_intersections/","title":"Mesh Intersections","text":"<p>This example demonstrates how to compute intersections between two triangle meshes using COMPAS CGAL.</p> <p>Key Features:</p> <ul> <li>Computing intersection curves between meshes</li> <li>Visualizing intersection results</li> <li>Handling multiple intersection curves</li> </ul> <pre><code>from compas.datastructures import Mesh\nfrom compas.geometry import Box\nfrom compas.geometry import Point\nfrom compas.geometry import Polyline\nfrom compas.geometry import Sphere\nfrom compas_viewer import Viewer\n\nfrom compas_cgal.intersections import intersection_mesh_mesh\n\n# ==============================================================================\n# Make a box and a sphere\n# ==============================================================================\n\nbox = Box(2)\nA = box.to_vertices_and_faces(triangulated=True)\n\nsphere = Sphere(1, point=[1, 1, 1])\nB = sphere.to_vertices_and_faces(u=32, v=32, triangulated=True)\n\n# ==============================================================================\n# Compute the intersections\n# ==============================================================================\n\npointsets = intersection_mesh_mesh(A, B)\n\n# ==============================================================================\n# Process output\n# ==============================================================================\n\npolylines = []\nfor points in pointsets:\n    points = [Point(*point) for point in points]\n    polyline = Polyline(points)\n    polylines.append(polyline)\n\n# =============================================================================\n# Visualize\n# ==============================================================================\n\nviewer = Viewer()\n\nviewer.renderer.camera.target = [0, 0, 0]\nviewer.renderer.camera.position = [4, -6, 3]\n\nviewer.scene.add(\n    Mesh.from_vertices_and_faces(*A),\n    facecolor=(1.0, 0.0, 0.0),\n    show_points=False,\n)\n\nviewer.scene.add(\n    Mesh.from_vertices_and_faces(*B),\n    facecolor=(0.0, 1.0, 0.0),\n    show_points=False,\n    opacity=0.3,\n)\n\nfor polyline in polylines:\n    viewer.scene.add(\n        polyline,\n        linecolor=(0.0, 0.0, 1.0),\n        lineswidth=3,\n        pointcolor=(0.0, 0.0, 1.0),\n        pointsize=20,\n        show_points=True,\n    )\n\nviewer.show()\n</code></pre>"},{"location":"examples/example_meshing/","title":"Mesh Remeshing","text":"<p>This example demonstrates how to remesh a triangle mesh using COMPAS CGAL.</p> <p>Key Features:</p> <ul> <li>Loading PLY mesh files</li> <li>Mesh transformation and centering</li> <li>Remeshing with target edge length</li> <li>Side-by-side visualization of original and remeshed models</li> </ul> <pre><code>from pathlib import Path\n\nfrom compas.datastructures import Mesh\nfrom compas_viewer import Viewer\n\nfrom compas_cgal.meshing import trimesh_remesh\n\n# =============================================================================\n# Input mesh\n# =============================================================================\n\ninput_file = Path(__file__).parent.parent.parent / \"data\" / \"rhinovault_mesh_0.ply\"\n\nmesh = Mesh.from_ply(input_file)\nmesh.quads_to_triangles()\n\nVF = mesh.to_vertices_and_faces()\n\n# =============================================================================\n# Remesh\n# =============================================================================\n\nV1, F1 = trimesh_remesh(VF, target_edge_length=1, number_of_iterations=10)\n\nremeshed = Mesh.from_vertices_and_faces(V1, F1)\n\n# ==============================================================================\n# Visualize\n# ==============================================================================\n\nviewer = Viewer(width=1600, height=900)\n\nviewer.scene.add(mesh, show_points=False, opacity=0.25)\nviewer.scene.add(remeshed, show_points=True)\n\nviewer.show()\n</code></pre>"},{"location":"examples/example_meshing_dual/","title":"Mesh Dual Remeshing","text":"<p>This example demonstrates how to remesh a triangle mesh using COMPAS CGAL.</p> <p>Key Features:</p> <ul> <li>Constrained Remeshing with Fixed Vertices</li> <li>Dual Remeshing with Target Edge Length</li> <li>Dual vertices are fixed by angle or/and vertex index.</li> </ul> <pre><code>from pathlib import Path\n\nfrom compas.datastructures import Mesh\nfrom compas.geometry import Line\nfrom compas_viewer import Viewer\n\nfrom compas_cgal.meshing import trimesh_dual\n\n# =============================================================================\n# Input mesh\n# =============================================================================\n\ninput_file = Path(__file__).parent.parent.parent / \"data\" / \"rhinovault_mesh_0.ply\"\nmesh = Mesh.from_ply(input_file)\nmesh.quads_to_triangles()\n\nfixed_vertices = []\nfor v in mesh.vertices():\n    if mesh.vertex_point(v).z &lt; 0.01:\n        fixed_vertices.append(v)\n\nVF = mesh.to_vertices_and_faces()\n\n# =============================================================================\n# Remesh\n# =============================================================================\n\nV2, F2, V3, F3 = trimesh_dual(\n    VF,\n    length_factor=1.0,\n    number_of_iterations=100,\n    angle_radians=0.9,\n    fixed_vertices=fixed_vertices,\n)\n\nremeshed = Mesh.from_vertices_and_faces(V2, F2)\ndual = Mesh.from_vertices_and_faces(V3, F3)\n\n# ==============================================================================\n# Visualize\n# ==============================================================================\n\nremeshed.translate([0, 0, 3])\n\nviewer = Viewer(width=1600, height=900)\n\nviewer.scene.add(mesh, show_points=False, opacity=0.25)\nviewer.scene.add(remeshed, show_points=True)\nviewer.scene.add(dual, show_points=True)\n\nfor v in dual.vertices():\n    viewer.scene.add(\n        Line(\n            dual.vertex_point(v),\n            dual.vertex_point(v) + dual.vertex_normal(v) * 0.25,\n        ),\n        color=(255, 0, 0),\n    )\n\nviewer.show()\n</code></pre>"},{"location":"examples/example_projection/","title":"Mesh Projection","text":"<p>This example demonstrates how to project a mesh to another mesh using COMPAS CGAL. By default closest point projection is used. The method can also use normals for ray-based projection.</p> <pre><code>from pathlib import Path\n\nfrom compas.datastructures import Mesh\nfrom compas.geometry import Point\nfrom compas_viewer import Viewer\n\nfrom compas_cgal.meshing import project_mesh_on_mesh\nfrom compas_cgal.meshing import project_points_on_mesh\nfrom compas_cgal.meshing import pull_mesh_on_mesh\nfrom compas_cgal.meshing import pull_points_on_mesh\n\n# =============================================================================\n# Source\n# =============================================================================\n\ninput_file_0 = Path(__file__).parent.parent.parent / \"data\" / \"rhinovault_mesh_0.ply\"\nmesh_0 = Mesh.from_ply(input_file_0)\n\n# =============================================================================\n# Target\n# =============================================================================\n\ninput_file_1 = Path(__file__).parent.parent.parent / \"data\" / \"rhinovault_mesh_1.ply\"\nmesh_1 = Mesh.from_ply(input_file_1)\n\n# =============================================================================\n# Source vertices and normals\n# =============================================================================\n\nv, f = mesh_0.to_vertices_and_faces()\nnormals = []\nfor i in range(len(v)):\n    normals.append(mesh_0.vertex_normal(i))\n\n# =============================================================================\n# Projection\n# =============================================================================\n\nmesh_result_project = project_mesh_on_mesh(mesh_0, mesh_1)\npoints_result_project = project_points_on_mesh(v, mesh_1)\n\n# =============================================================================\n# Pulling\n# =============================================================================\n\nmesh_result_pull = pull_mesh_on_mesh(mesh_0, mesh_1)\npoints_result_pull = pull_points_on_mesh(v, normals, mesh_1)\n\n# ==============================================================================\n# Visualize\n# ==============================================================================\n\nviewer = Viewer()\nviewer.renderer.camera.target = [0, 0, 1.5]\nviewer.renderer.camera.position = [-5, -5, 1.5]\n\nviewer.scene.add(mesh_0, name=\"source mesh_0\", show_faces=False)\nviewer.scene.add(mesh_1, name=\"target mesh_1\", show_faces=False)\n\nviewer.scene.add(mesh_result_project, name=\"projected mesh\", color=[255, 0, 0])\nviewer.scene.add(mesh_result_pull, name=\"pulled mesh\", color=[0, 255, 0])\n\ngroup_projected = viewer.scene.add_group(\"projected points\")\nfor i, point in enumerate(points_result_project):\n    group_projected.add(Point(*point), name=f\"point_{i}\", color=[0, 0, 0])\n\ngroup_pulled = viewer.scene.add_group(\"pulled points\")\nfor i, point in enumerate(points_result_pull):\n    group_pulled.add(Point(*point), name=f\"point_{i}\", color=[0, 0, 0])\n\nviewer.show()\n</code></pre>"},{"location":"examples/example_reconstruction_pointset_normal_estimation/","title":"Point Cloud Normal Estimation","text":"<p>This example demonstrates how to estimate normals from a point cloud using COMPAS CGAL.</p> <p>Key Features:</p> <ul> <li>Loading point clouds from PLY files</li> <li>Point cloud density reduction</li> <li>Normal estimation using k-nearest neighbors</li> <li>Visualization of point normals as scaled lines</li> </ul> <pre><code>from pathlib import Path\n\nfrom compas.geometry import Line\nfrom compas.geometry import Pointcloud\nfrom compas_viewer import Viewer\nfrom compas_viewer.config import Config\n\nfrom compas_cgal.reconstruction import pointset_normal_estimation\nfrom compas_cgal.reconstruction import pointset_reduction\n\n# ==============================================================================\n# Input geometry\n# ==============================================================================\n\nFILE = Path(__file__).parent.parent.parent / \"data\" / \"forked_branch_1.ply\"\n\ncloud = Pointcloud.from_ply(FILE)\nreduced_cloud = Pointcloud(pointset_reduction(cloud, 10))\npoints, vectors = pointset_normal_estimation(reduced_cloud, 16, True)\n\n# ==============================================================================\n# Compute\n# ==============================================================================\n\nlines = []\nline_scale = 10\n\nfor p, v in zip(points, vectors):\n    line = Line(\n        [p[0], p[1], p[2]],\n        [\n            p[0] + v[0] * line_scale,\n            p[1] + v[1] * line_scale,\n            p[2] + v[2] * line_scale,\n        ],\n    )\n    lines.append(line)\n\n# ==============================================================================\n# Visualize\n# ==============================================================================\n\nconfig = Config()\nconfig.unit = \"mm\"\n\nviewer = Viewer(config=config)\n\ngroup = viewer.scene.add_group(\"pointset\")\ngroup.add_from_list(lines)\n\nviewer.show()\n</code></pre>"},{"location":"examples/example_reconstruction_pointset_outlier_removal/","title":"Point Cloud Outlier Removal","text":"<p>This example demonstrates how to remove outliers from a point cloud using COMPAS CGAL.</p> <p>Key Features:</p> <ul> <li>Loading point clouds from PLY files</li> <li>Removing outliers based on neighborhood analysis</li> <li>Visualization of inliers and outliers with different colors</li> <li>Point cloud difference computation</li> </ul> <pre><code>from pathlib import Path\n\nfrom compas.geometry import Pointcloud\nfrom compas_viewer import Viewer\nfrom compas_viewer.config import Config\n\nfrom compas_cgal.reconstruction import pointset_outlier_removal\n\n# ==============================================================================\n# Input geometry\n# ==============================================================================\n\nFILE = Path(__file__).parent.parent.parent / \"data\" / \"forked_branch_1.ply\"\nc1 = Pointcloud.from_ply(FILE)\n\n# ==============================================================================\n# Compute\n# ==============================================================================\n\npoints = pointset_outlier_removal(c1, 30, 2.0)\n\nc2 = Pointcloud(points)\nc3 = c1.difference(c2)\n\n# ==============================================================================\n# Visualize\n# ==============================================================================\n\nconfig = Config()\nconfig.unit = \"mm\"\n\nviewer = Viewer(config=config)\n\nviewer.scene.add(c2, pointcolor=(0.0, 0.0, 0.0))\nviewer.scene.add(c3, pointcolor=(1.0, 0.0, 0.0))\n\nviewer.show()\n</code></pre>"},{"location":"examples/example_reconstruction_pointset_reduction/","title":"Point Cloud Reduction","text":"<p>This example demonstrates how to reduce the density of a point cloud using COMPAS CGAL.</p> <p>Key Features:</p> <ul> <li>Loading point clouds from PLY files</li> <li>Point cloud density reduction with specified percentage</li> <li>Side-by-side visualization of original and reduced point clouds</li> </ul> <pre><code>from pathlib import Path\n\nfrom compas.geometry import Pointcloud\nfrom compas.geometry import Translation\nfrom compas_viewer import Viewer\nfrom compas_viewer.config import Config\n\nfrom compas_cgal.reconstruction import pointset_reduction\n\n# =============================================================================\n# Input\n# =============================================================================\n\nFILE = Path(__file__).parent.parent.parent / \"data\" / \"forked_branch_1.ply\"\ncloud = Pointcloud.from_ply(FILE)\n\n# =============================================================================\n# Reduction\n# =============================================================================\n\ncloud_reduced = Pointcloud(pointset_reduction(cloud, 50))\ncloud_reduced.transform(Translation.from_vector([-1000, 0, 0]))\n\n# =============================================================================\n# Viz\n# =============================================================================\n\nconfig = Config()\nconfig.unit = \"mm\"\n\nviewer = Viewer(config=config)\n\nviewer.scene.add(cloud, pointcolor=(0.0, 0.0, 0.0))\nviewer.scene.add(cloud_reduced, pointcolor=(1.0, 0.0, 0.0))\n\nviewer.show()\n</code></pre>"},{"location":"examples/example_reconstruction_pointset_smoothing/","title":"Point Cloud Smoothing","text":"<p>This example demonstrates how to smooth a point cloud using COMPAS CGAL.</p> <p>Key Features:</p> <ul> <li>Loading point clouds from PLY files</li> <li>Point cloud smoothing with specified iterations and neighborhood size</li> <li>Side-by-side visualization of original and smoothed point clouds</li> </ul> <pre><code>from pathlib import Path\n\nfrom compas.geometry import Pointcloud\nfrom compas_viewer import Viewer\nfrom compas_viewer.config import Config\n\nfrom compas_cgal.reconstruction import pointset_smoothing\n\n# =============================================================================\n# Input\n# =============================================================================\n\nply_file_path = Path(__file__).parent.parent.parent / \"data\" / \"box.ply\"\noriginal_points = Pointcloud.from_ply(ply_file_path)\n\n# =============================================================================\n# Smoothing\n# =============================================================================\n\nsmoothed_points = Pointcloud(pointset_smoothing(original_points, 100, 3))\n\n# ==============================================================================\n# Visualize\n# ==============================================================================\n\nconfig = Config()\nconfig.unit = \"mm\"\n\nviewer = Viewer(config=config)\nviewer.scene.add(original_points, pointcolor=(0.0, 0.0, 0.0), pointsize=3)\nviewer.scene.add(smoothed_points, pointcolor=(1.0, 0.0, 0.0), pointsize=7)\nviewer.show()\n</code></pre>"},{"location":"examples/example_reconstruction_poisson_surface_reconstruction/","title":"Poisson Surface Reconstruction","text":"<p>This example demonstrates how to perform Poisson surface reconstruction from a point cloud with normals using COMPAS CGAL.</p> <p>Key Features:</p> <ul> <li>Loading point clouds with normals from XYZ files</li> <li>Poisson surface reconstruction to create a mesh</li> <li>Mesh transformation and visualization</li> <li>Side-by-side display of input points and reconstructed mesh</li> </ul> <pre><code>from pathlib import Path\n\nfrom compas.datastructures import Mesh\nfrom compas_viewer import Viewer\n\nfrom compas_cgal.reconstruction import poisson_surface_reconstruction\n\n# =============================================================================\n# Input\n# =============================================================================\n\nFILE = Path(__file__).parent.parent.parent / \"data\" / \"oni.xyz\"\n\npoints = []\nnormals = []\nwith open(FILE, \"r\") as f:\n    for line in f:\n        x, y, z, nx, ny, nz = line.strip().split()\n        points.append([float(x), float(y), float(z)])\n        normals.append([float(nx), float(ny), float(nz)])\n\n# =============================================================================\n# Reconstruction\n# =============================================================================\n\n# Reconstruct surface with custom parameters\n# Using larger sm_radius and sm_distance values reduces mesh complexity\n# and helps filter out vertices that don't belong to the original point cloud\nV, F = poisson_surface_reconstruction(\n    points,\n    normals,\n    sm_angle=20.0,  # Surface meshing angle bound (degrees)\n    sm_radius=30.0,  # Surface meshing radius bound (factor of avg spacing)\n    sm_distance=0.375,  # Surface meshing distance bound (factor of avg spacing)\n)\nmesh = Mesh.from_vertices_and_faces(V, F)\n\n# ==============================================================================\n# Visualize\n# ==============================================================================\n\nviewer = Viewer()\n\nviewer.renderer.camera.target = [0, 0, 0]\nviewer.renderer.camera.position = [0, -0.2, 2.0]\n\nviewer.scene.add(points, pointsize=10, pointcolor=(255, 0, 0))\nviewer.scene.add(mesh, show_points=False)\n\nviewer.show()\n</code></pre>"},{"location":"examples/example_simplify_polylines/","title":"Polyline Simplification","text":"<p>This example demonstrates how to simplify polylines using the Douglas-Peucker algorithm in COMPAS CGAL.</p> <p>Key Features:</p> <ul> <li>Douglas-Peucker polyline simplification</li> <li>XY-plane simplification with Z-coordinate preservation</li> <li>Side-by-side visualization of original and simplified polylines</li> </ul> <pre><code>import numpy as np\nfrom compas.geometry import Polyline\nfrom compas_viewer import Viewer\nfrom compas_viewer.config import Config\n\nfrom compas_cgal.polylines import simplify_polyline\n\n# =============================================================================\n# Create a complex polyline: spiral with noise\n# =============================================================================\n\nn_points = 200\nt = np.linspace(0, 6 * np.pi, n_points)\nradius = 1 + t / 10\nnoise = np.random.uniform(-0.05, 0.05, n_points)\n\nx = radius * np.cos(t) + noise\ny = radius * np.sin(t) + noise\nz = t / 5\n\noriginal_points = np.column_stack([x, y, z])\n\n# =============================================================================\n# Simplify\n# =============================================================================\n\nsimplified_high = simplify_polyline(original_points, threshold=0.5)\n\n# =============================================================================\n# Create polylines offset in X for visualization\n# =============================================================================\n\noffset = 6.0\noriginal_polyline = Polyline(original_points.tolist())\nsimplified_high_polyline = Polyline((simplified_high + [offset, 0, 0]).tolist())\n\n# ==============================================================================\n# Visualize\n# ==============================================================================\n\nconfig = Config()\nconfig.camera.target = [5, 0, 5]\nconfig.camera.position = [5, -20, 10]\n\nviewer = Viewer(config=config)\n\nviewer.scene.add(original_polyline, linewidth=2, show_points=False)\nviewer.scene.add(simplified_high_polyline, linewidth=3, show_points=False)\n\nviewer.show()\n</code></pre>"},{"location":"examples/example_skeletonization/","title":"Mesh Skeletonization","text":"<p>This example demonstrates how to compute the geometric skeleton of a triangle mesh using COMPAS CGAL.</p> <p>Key Features:</p> <ul> <li>Loading and transforming OFF mesh files</li> <li>Mesh subdivision using Loop scheme</li> <li>Skeleton computation using mean curvature flow</li> <li>Visualization of mesh and skeleton polylines</li> </ul> <pre><code>import math\nfrom pathlib import Path\n\nfrom compas.datastructures import Mesh\nfrom compas.geometry import Polyline\nfrom compas.geometry import Rotation\nfrom compas.geometry import Scale\nfrom compas.geometry import Translation\nfrom compas_viewer import Viewer\n\nfrom compas_cgal.skeletonization import mesh_skeleton\n\n# =============================================================================\n# Input\n# =============================================================================\n\ninput_file = Path(__file__).parent.parent.parent / \"data\" / \"elephant.off\"\n\nrotation_x = Rotation.from_axis_and_angle([1, 0, 0], math.radians(60))\nrotation_y = Rotation.from_axis_and_angle([0, 1, 0], math.radians(5))\nrotation = rotation_y * rotation_x\nscale = Scale.from_factors([5, 5, 5])\ntranslation = Translation.from_vector([0, 0, 2])\n\nmesh = Mesh.from_off(input_file).transformed(translation * rotation * scale)\n\nv, f = mesh.to_vertices_and_faces(triangulated=True)\n\n# =============================================================================\n# Skeleton\n# =============================================================================\n\nskeleton_edges = mesh_skeleton((v, f))\n\npolylines = []\nfor start_point, end_point in skeleton_edges:\n    polyline = Polyline([start_point, end_point])\n    polylines.append(polyline)\n\n# ==============================================================================\n# Visualize\n# ==============================================================================\n\nviewer = Viewer()\nviewer.renderer.camera.target = [0, 0, 1.5]\nviewer.renderer.camera.position = [-5, -5, 1.5]\n\nviewer.scene.add(mesh, opacity=0.5, show_points=False)\n\nfor polyline in polylines:\n    viewer.scene.add(polyline, linewidth=5, show_points=True)\n\nviewer.show()\n</code></pre>"},{"location":"examples/example_skeletonization_with_mapping/","title":"Mesh Skeletonization with Vertex Mapping","text":"<p>This example demonstrates how to compute the geometric skeleton of a triangle mesh with vertex correspondence mapping using COMPAS CGAL.</p> <p>Key Features:</p> <ul> <li>Computing skeleton with vertex correspondence information</li> <li>Understanding which original mesh vertices map to each skeleton vertex</li> <li>Colored visualization showing vertex mapping</li> <li>Printing mapping statistics to understand the correspondence</li> </ul> <pre><code>import math\nfrom pathlib import Path\n\nfrom compas.datastructures import Mesh\nfrom compas.geometry import Point\nfrom compas.geometry import Polyline\nfrom compas.geometry import Rotation\nfrom compas.geometry import Scale\nfrom compas.geometry import Translation\nfrom compas_viewer import Viewer\n\nfrom compas_cgal.skeletonization import mesh_skeleton_with_mapping\n\n# =============================================================================\n# Input\n# =============================================================================\n\ninput_file = Path(__file__).parent.parent.parent / \"data\" / \"elephant.off\"\n\nR1 = Rotation.from_axis_and_angle([1, 0, 0], math.radians(60))\nR2 = Rotation.from_axis_and_angle([0, 1, 0], math.radians(5))\nT = Translation.from_vector([0, 0, 2])\nS = Scale.from_factors([5, 5, 5])\n\ntransform = T * R2 * R1 * S\n\nmesh = Mesh.from_off(input_file).transformed(transform)\nv, f = mesh.to_vertices_and_faces(triangulated=True)\n\n# =============================================================================\n# Compute skeleton with vertex mapping\n# =============================================================================\n\nskeleton_edges, vertex_indices = mesh_skeleton_with_mapping((v, f))\n\n# Create polylines for skeleton edges\n\npolylines = [Polyline([start, end]) for start, end in skeleton_edges]\n\n# Select edge to highlight (100th or last if fewer edges)\n\nedge_idx = min(100, len(vertex_indices) - 1)\nstart_indices, end_indices = vertex_indices[edge_idx]\n\nprint(f\"Mesh: {len(v)} vertices, Skeleton: {len(skeleton_edges)} edges\")\nprint(f\"Edge {edge_idx}: {len(start_indices)} vertices \u2192 start, {len(end_indices)} vertices \u2192 end\")\n\n# =============================================================================\n# Viz\n# =============================================================================\n\nviewer = Viewer()\n\nviewer.renderer.camera.target = [0, 0, 1.5]\nviewer.renderer.camera.position = [-5, -5, 1.5]\n\nviewer.scene.add(mesh, opacity=0.2, show_points=False, facecolor=[0.9, 0.9, 0.9])\n\nfor idx in start_indices:\n    viewer.scene.add(Point(*v[idx]), pointcolor=[1.0, 0.0, 0.0], pointsize=15)  # red = start\nfor idx in end_indices:\n    viewer.scene.add(Point(*v[idx]), pointcolor=[0.0, 0.0, 1.0], pointsize=15)  # blue = end\n\nfor i, polyline in enumerate(polylines):\n    if i == edge_idx:\n        viewer.scene.add(\n            polyline,\n            linewidth=10,\n            linecolor=[1.0, 1.0, 0.0],\n            show_points=True,\n            pointsize=20,\n        )\n    else:\n        viewer.scene.add(\n            polyline,\n            linewidth=3,\n            linecolor=[0.5, 0.5, 0.5],\n            show_points=False,\n        )\n\nviewer.show()\n</code></pre>"},{"location":"examples/example_slicer/","title":"Mesh Slicing","text":"<p>This example demonstrates how to slice a mesh with multiple planes using COMPAS CGAL.</p> <p>Key Features:</p> <ul> <li>Loading STL mesh files</li> <li>Creating multiple slice planes from bounding box</li> <li>Slicing mesh with multiple planes</li> <li>Converting slice results to polylines</li> <li>Visualization with semi-transparent mesh and slice curves</li> </ul> <pre><code>from pathlib import Path\n\nimport numpy as np\nfrom compas.datastructures import Mesh\nfrom compas.geometry import Plane\nfrom compas.geometry import Point\nfrom compas.geometry import Polyline\nfrom compas.geometry import Vector\nfrom compas_viewer import Viewer\nfrom compas_viewer.config import Config\n\nfrom compas_cgal.slicer import slice_mesh\n\n# =============================================================================\n# Get Mesh from STL\n# =============================================================================\n\nFILE = Path(__file__).parent.parent.parent / \"data\" / \"3DBenchy.stl\"\nbenchy = Mesh.from_stl(FILE)\n\nV, F = benchy.to_vertices_and_faces()\n\n# =============================================================================\n# Get Slice planes from the bounding box\n# =============================================================================\n\nbbox = benchy.aabb()\nnormal = Vector(0, 0, 1)\nplanes = []\nfor i in np.linspace(bbox.zmin, bbox.zmax, 50):\n    plane = Plane(Point(0, 0, i), normal)\n    planes.append(plane)\n\n# =============================================================================\n# Slice\n# =============================================================================\n\nslicer_polylines = slice_mesh((V, F), planes)\n\npolylines = []\nfor polyline in slicer_polylines:\n    points = []\n    for point in polyline:\n        points.append(Point(*point))\n    polylines.append(Polyline(points))\n\n# ==============================================================================\n# Visualize\n# ==============================================================================\n\nconfig = Config()\n\nviewer = Viewer(config=config)\n\nviewer.scene.add(benchy, opacity=0.5, show_lines=False, show_points=False)\n\nfor polyline in polylines:\n    viewer.scene.add(polyline, linewidth=2, show_points=False)\n\nviewer.show()\n</code></pre>"},{"location":"examples/example_straight_skeleton_2_interior_straight_skeleton/","title":"Interior Straight Skeleton","text":"<p>This example demonstrates how to compute the interior straight skeleton of a polygon using COMPAS CGAL.</p> <p>Key Features:</p> <ul> <li>Computing straight skeleton from polygon points</li> <li>Visualization of inner bisectors and edges</li> <li>Color-coded display of different edge types</li> </ul> <pre><code>from compas.geometry import Point\nfrom compas.geometry import Polygon\nfrom compas_viewer import Viewer\n\nfrom compas_cgal.straight_skeleton_2 import interior_straight_skeleton\n\npoints = [\n    Point(-1.91, 3.59, 0.0),\n    Point(-5.53, -5.22, 0.0),\n    Point(-0.39, -1.98, 0.0),\n    Point(2.98, -5.51, 0.0),\n    Point(4.83, -2.02, 0.0),\n    Point(9.70, -3.63, 0.0),\n    Point(12.23, 1.25, 0.0),\n    Point(3.42, 0.66, 0.0),\n    Point(2.92, 4.03, 0.0),\n    Point(-1.91, 3.59, 0.0),\n]\npolygon = Polygon(points)\n\ngraph = interior_straight_skeleton(polygon)\n\n# ==============================================================================\n# Visualize\n# ==============================================================================\n\nviewer = Viewer()\n\nfor edge in graph.edges():\n    line = graph.edge_line(edge)\n    if graph.edge_attribute(edge, \"inner_bisector\"):\n        viewer.scene.add(line, linecolor=(1.0, 0.0, 0.0), linewidth=2)\n    elif graph.edge_attribute(edge, \"bisector\"):\n        viewer.scene.add(line, linecolor=(0.0, 0.0, 1.0))\n    else:\n        viewer.scene.add(line, linecolor=(0.0, 0.0, 0.0))\n\nviewer.show()\n</code></pre>"},{"location":"examples/example_straight_skeleton_2_interior_straight_skeleton_offset_polygon/","title":"Polygon Offsetting","text":"<p>This example demonstrates how to create offset polygons (inward and outward) using COMPAS CGAL.</p> <p>Key Features:</p> <ul> <li>Creating inner and outer polygon offsets</li> <li>Handling complex polygon shapes</li> <li>Color-coded visualization of original and offset polygons</li> </ul> <pre><code>from compas.geometry import Polygon\nfrom compas_viewer import Viewer\n\nfrom compas_cgal.straight_skeleton_2 import offset_polygon\nfrom compas_cgal.straight_skeleton_2 import offset_polygon_with_holes\n\npoints = [\n    (-1.91, 3.59, 0.0),\n    (-5.53, -5.22, 0.0),\n    (-0.39, -1.98, 0.0),\n    (2.98, -5.51, 0.0),\n    (4.83, -2.02, 0.0),\n    (9.70, -3.63, 0.0),\n    (12.23, 1.25, 0.0),\n    (3.42, 0.66, 0.0),\n    (2.92, 4.03, 0.0),\n    (-1.91, 3.59, 0.0),\n]\npolygon = Polygon(points)\noffset = 1.5\n\noffset_polygon_inner = offset_polygon(points, offset)\noffset_polygon_outer = offset_polygon(points, -offset)\n\n\nresult = offset_polygon_with_holes(offset_polygon_outer[0], offset_polygon_inner, -0.1)\n\n# ==============================================================================\n# Visualize\n# ==============================================================================\n\nviewer = Viewer()\nviewer.config.renderer.show_grid = False\n\nviewer.scene.add(polygon, show_faces=False)\n\nfor opolygon in offset_polygon_inner:\n    viewer.scene.add(\n        opolygon,\n        linecolor=(1.0, 0.0, 0.0),\n        facecolor=(1.0, 0.0, 0.0, 0.0),\n        show_faces=False,\n    )\n\nfor opolygon in offset_polygon_outer:\n    viewer.scene.add(\n        opolygon,\n        linecolor=(0.0, 0.0, 1.0),\n        facecolor=(0.0, 0.0, 1.0, 0.0),\n        show_faces=False,\n    )\n\nfor opolygon, holes in result:\n    viewer.scene.add(\n        opolygon,\n        linecolor=(0.0, 0.0, 1.0),\n        facecolor=(0.0, 0.0, 1.0, 0.0),\n        show_faces=False,\n    )\n    for hole in holes:\n        viewer.scene.add(\n            hole,\n            linecolor=(0.0, 0.0, 1.0),\n            facecolor=(0.0, 0.0, 1.0, 0.0),\n            show_faces=False,\n        )\n\nviewer.show()\n</code></pre>"},{"location":"examples/example_straight_skeleton_2_interior_straight_skeleton_weighted_offset_polygon/","title":"Weighted Polygon Offsetting","text":"<p>This example demonstrates how to create weighted offset polygons using COMPAS CGAL.</p> <p>Key Features:</p> <ul> <li>Creating weighted polygon offsets</li> <li>Specifying different weights for each edge</li> <li>Visualization of original and weighted offset polygons</li> </ul> <pre><code>from compas.geometry import Polygon\nfrom compas_viewer import Viewer\n\nfrom compas_cgal.straight_skeleton_2 import weighted_offset_polygon\n\npoints = [\n    (-1.91, 3.59, 0.0),\n    (-5.53, -5.22, 0.0),\n    (-0.39, -1.98, 0.0),\n    (2.98, -5.51, 0.0),\n    (4.83, -2.02, 0.0),\n    (9.70, -3.63, 0.0),\n    (12.23, 1.25, 0.0),\n    (3.42, 0.66, 0.0),\n    (2.92, 4.03, 0.0),\n    (-1.91, 3.59, 0.0),\n]\npolygon = Polygon(points)\n\ndistances = [0.1, 0.3, 0.6, 0.1, 0.7, 0.5, 0.2, 0.4, 0.8, 0.2]\nweights = [1.0 / d for d in distances]\noffset = 1.0\noffset_polygons_outer = weighted_offset_polygon(points, -offset, weights)\n\n# ==============================================================================\n# Visualize\n# ==============================================================================\n\nviewer = Viewer()\nviewer.scene.add(polygon)\nviewer.config.renderer.show_grid = False\n\nfor opolygon in offset_polygons_outer:\n    viewer.scene.add(opolygon, linecolor=(0.0, 0.0, 1.0), facecolor=(1.0, 1.0, 1.0, 0.0))\n\nviewer.show()\n</code></pre>"},{"location":"examples/example_straight_skeleton_2_interior_straight_skeleton_with_holes/","title":"Straight Skeleton with Holes","text":"<p>This example demonstrates how to compute the straight skeleton of a polygon with holes using COMPAS CGAL.</p> <p>Key Features:</p> <ul> <li>Computing straight skeleton for polygons with holes</li> <li>Handling multiple interior holes</li> <li>Color-coded visualization of different edge types</li> <li>Distinction between inner bisectors and regular edges</li> </ul> <pre><code>from compas.geometry import Polygon\nfrom compas_viewer import Viewer\n\nfrom compas_cgal.straight_skeleton_2 import interior_straight_skeleton_with_holes\n\n# =============================================================================\n# Outer boundary\n# =============================================================================\n\npoints_boundary = [\n    (-1.91, 3.59, 0.0),\n    (-5.53, -5.22, 0.0),\n    (-0.39, -1.98, 0.0),\n    (2.98, -5.51, 0.0),\n    (4.83, -2.02, 0.0),\n    (9.70, -3.63, 0.0),\n    (12.23, 1.25, 0.0),\n    (3.42, 0.66, 0.0),\n    (2.92, 4.03, 0.0),\n    (-1.91, 3.59, 0.0),\n]\nboundary = Polygon(points_boundary)\n\n# =============================================================================\n# Inner holes\n# =============================================================================\n\nholes = [\n    [(0.42, 0.88, 0.0), (1.1, -1.0, 0.0), (-1.97, -0.93, 0.0), (-1.25, 1.82, 0.0)],\n    [(4.25, -0.64, 0.0), (2.9, -3.03, 0.0), (2.12, -2.16, 0.0), (2.89, -0.36, 0.0)],\n    [(10.6, 0.29, 0.0), (9.48, -1.54, 0.0), (5.48, -1.26, 0.0), (5.98, -0.04, 0.0)],\n]\nholes = [Polygon(hole) for hole in holes]\n\n# =============================================================================\n# Skeleton\n# =============================================================================\n\ngraph = interior_straight_skeleton_with_holes(boundary, holes)\n\n# ==============================================================================\n# Visualize\n# ==============================================================================\n\nviewer = Viewer()\n\nfor edge in graph.edges():\n    line = graph.edge_line(edge)\n    if graph.edge_attribute(edge, \"inner_bisector\"):\n        viewer.scene.add(line, linecolor=(1.0, 0.0, 0.0), linewidth=2)\n    elif graph.edge_attribute(edge, \"bisector\"):\n        viewer.scene.add(line, linecolor=(0.0, 0.0, 1.0))\n    else:\n        viewer.scene.add(line, linecolor=(0.0, 0.0, 0.0))\n\nviewer.show()\n</code></pre>"},{"location":"examples/example_subdivision/","title":"Mesh Subdivision","text":"<p>This example demonstrates different mesh subdivision schemes available in COMPAS CGAL.</p> <p>Key Features:</p> <ul> <li>Catmull-Clark subdivision for quad meshes</li> <li>Loop subdivision for triangle meshes</li> <li>\u221a3 (sqrt3) subdivision for triangle meshes</li> <li>Side-by-side comparison of different subdivision methods</li> </ul> <pre><code>from compas.geometry import Box\nfrom compas.geometry import Polyhedron\nfrom compas.geometry import Translation\nfrom compas_viewer import Viewer\n\nfrom compas_cgal.subdivision import mesh_subdivide_catmull_clark\nfrom compas_cgal.subdivision import mesh_subdivide_loop\nfrom compas_cgal.subdivision import mesh_subdivide_sqrt3\n\n\n# ==============================================================================\n# Input geometry\n# ==============================================================================\n\nbox = Box.from_diagonal(([0, 0, 0], [1, 1, 1]))\n\nV0, F0 = box.to_vertices_and_faces(triangulated=False)\nV1, F1 = box.to_vertices_and_faces(triangulated=False)\nV2, F2 = box.to_vertices_and_faces(triangulated=True)\nV3, F3 = box.to_vertices_and_faces(triangulated=True)\n\n# ==============================================================================\n# Compute\n# ==============================================================================\n\nV4, F4 = mesh_subdivide_catmull_clark((V1, F1), 3)\nV5, F5 = mesh_subdivide_loop((V2, F2), 3)\nV6, F6 = mesh_subdivide_sqrt3((V3, F3), 3)\n\nS2 = Polyhedron(V0, F0)\nS4 = Polyhedron(V4.tolist(), F4.tolist())\nS6 = Polyhedron(V5.tolist(), F5.tolist())\nS8 = Polyhedron(V6.tolist(), F6.tolist())\n\nS2.transform(Translation.from_vector([1, 0, 0]))\nS4.transform(Translation.from_vector([2, 0, 0]))\nS6.transform(Translation.from_vector([3, 0, 0]))\nS8.transform(Translation.from_vector([4, 0, 0]))\n\n# ==============================================================================\n# Visualize\n# ==============================================================================\n\nviewer = Viewer()\n\nviewer.renderer.camera.target = [3, 1, 0.5]\nviewer.renderer.camera.position = [5, -2, 0.5]\n\nviewer.scene.add(S2.to_mesh(), show_points=False)\nviewer.scene.add(S4.to_mesh(), show_points=False)\nviewer.scene.add(S6.to_mesh(), show_points=False)\nviewer.scene.add(S8.to_mesh(), show_points=False)\n\nviewer.show()\n</code></pre>"},{"location":"examples/example_triangulation/","title":"Mesh Triangulation","text":"<p>This example demonstrates how to perform constrained and refined Delaunay triangulation using COMPAS CGAL.</p> <p>Key Features:</p> <ul> <li>Creating polygonal boundary and holes</li> <li>Conforming Delaunay triangulation</li> <li>Refined Delaunay meshing with size constraints</li> <li>Side-by-side visualization of different triangulation methods</li> </ul> <pre><code>from compas.datastructures import Mesh\nfrom compas.geometry import Polygon\nfrom compas.geometry import Translation\nfrom compas_viewer import Viewer\n\nfrom compas_cgal.triangulation import conforming_delaunay_triangulation\nfrom compas_cgal.triangulation import refined_delaunay_mesh\n\nboundary = Polygon.from_sides_and_radius_xy(64, 4)\n\nhole = Polygon.from_sides_and_radius_xy(128, 1)\n\nhole1 = hole.transformed(Translation.from_vector([2, 0, 0]))\nhole2 = hole.transformed(Translation.from_vector([-2, 0, 0]))\nhole3 = hole.transformed(Translation.from_vector([0, 2, 0]))\nhole4 = hole.transformed(Translation.from_vector([0, -2, 0]))\n\nholes = [hole1, hole2, hole3, hole4]\n\nV, F = conforming_delaunay_triangulation(\n    boundary,\n    holes=holes,\n)\n\ncdt = Mesh.from_vertices_and_faces(V, F)\n\nV, F = refined_delaunay_mesh(\n    boundary,\n    holes=holes,\n    maxlength=0.5,\n    is_optimized=True,\n)\n\nrdm = Mesh.from_vertices_and_faces(V, F)\n\n# ==============================================================================\n# Visualize\n# ==============================================================================\n\nviewer = Viewer()\n\nviewer.renderer.camera.target = [0, 0, 0]\nviewer.renderer.camera.position = [0, -1, 13]\n\nviewer.scene.add(cdt.transformed(Translation.from_vector([-5, 0, 0])))\nviewer.scene.add(rdm.transformed(Translation.from_vector([+5, 0, 0])))\n\nviewer.show()\n</code></pre>"}]}